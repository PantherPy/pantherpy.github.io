{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#panther","title":"Panther","text":"<p>Is A Fast &amp;  Friendly Web Framework For Building Async APIs With Python 3.10+ </p> <p> </p> <p> <p> </p> <p></p>"},{"location":"#why-use-panther","title":"Why Use Panther ?","text":"<ul> <li>Include Simple File-Base Database (PantherDB)</li> <li>Built-in Document-oriented Databases ODM (MongoDB, PantherDB)</li> <li>Built-in Websocket Support</li> <li>Built-in API Caching System (In Memory, Redis)</li> <li>Built-in Authentication Classes</li> <li>Built-in Permission Classes</li> <li>Built-in Visual API Monitoring (In Terminal)</li> <li>Support Custom Background Tasks</li> <li>Support Custom Middlewares</li> <li>Support Custom Throttling</li> <li>Support Function-Base and Class-Base APIs</li> <li>It's One Of The Fastest Python Framework </li> </ul>"},{"location":"#supported-by","title":"Supported by","text":""},{"location":"#installation","title":"Installation","text":"<ul> <li> 1. Create a Virtual Environment <pre>$ python3 -m venv .venv</pre> <ul> <li> 2. Active The Environment<ul> <li>Linux &amp; Mac   <pre>$ source .venv/bin/activate</pre></li> <li>Windows   <pre>$ ..venv\\Scripts\\activate</pre></li> </ul> <ul> <li> 3. Install Panther<ul> <li>\u2b07 Normal Installation   <pre>$ pip install panther</pre></li> <li>\u2b07 Include full requirements (MongoDB, JWTAuth, Ruff, Redis, Websockets, Cryptography, bpython)   <pre>$ pip install panther[full]</pre> </li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#create-project","title":"Create Project","text":"<pre><code>$ panther create\n</code></pre>"},{"location":"#run-project","title":"Run Project","text":"<p><pre><code>$ panther run --reload\n</code></pre> * Panther uses Uvicorn as ASGI (Asynchronous Server Gateway Interface) but you can run the project with Granian, daphne or any ASGI server</p>"},{"location":"#monitoring-requests","title":"Monitoring Requests","text":"<pre><code>$ panther monitor \n</code></pre>"},{"location":"#python-shell","title":"Python Shell","text":"<pre><code>$ panther shell\n</code></pre>"},{"location":"#api-example","title":"API Example","text":"<ul> <li> <p>Create <code>main.py</code></p> <pre><code>from datetime import datetime, timedelta\n\nfrom panther import status, Panther\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\n\nclass FirstAPI(GenericAPI):\n    # Cache Response For 10 Seconds\n    cache = True\n    cache_exp_time = timedelta(seconds=10)\n\n    def get(self):\n        date_time = datetime.now().isoformat()\n        data = {'detail': f'Hello World | {date_time}'}\n        return Response(data=data, status_code=status.HTTP_202_ACCEPTED)\n\n\nurl_routing = {'': FirstAPI}\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre> </li> <li> <p>Run the project:</p> <ul> <li><code>$ panther run --reload</code> </li> </ul> </li> <li> <p>Checkout the http://127.0.0.1:8000/</p> </li> </ul>"},{"location":"#websocket-echo-example","title":"WebSocket Echo Example","text":"<ul> <li> <p>Create <code>main.py</code></p> <pre><code>from panther import Panther\nfrom panther.app import GenericAPI\nfrom panther.response import HTMLResponse\nfrom panther.websocket import GenericWebsocket\n\n\nclass FirstWebsocket(GenericWebsocket):\n    async def connect(self, **kwargs):\n        await self.accept()\n\n    async def receive(self, data: str | bytes):\n        await self.send(data)\n\n\nclass MainPage(GenericAPI):\n    def get(self):\n        template = \"\"\"\n        &lt;input type=\"text\" id=\"messageInput\"&gt;\n        &lt;button id=\"sendButton\"&gt;Send Message&lt;/button&gt;\n        &lt;ul id=\"messages\"&gt;&lt;/ul&gt;\n        &lt;script&gt;\n            var socket = new WebSocket('ws://127.0.0.1:8000/ws');\n            socket.addEventListener('message', function (event) {\n                var li = document.createElement('li');\n                document.getElementById('messages').appendChild(li).textContent = 'Server: ' + event.data;\n            });\n            function sendMessage() {\n                socket.send(document.getElementById('messageInput').value);\n            }\n            document.getElementById('sendButton').addEventListener('click', sendMessage);\n        &lt;/script&gt;\n        \"\"\"\n        return HTMLResponse(template)\n\nurl_routing = {\n    '': MainPage,\n    'ws': FirstWebsocket,\n}\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre> </li> <li> <p>Run the project:</p> <ul> <li><code>$ panther run --reload</code> </li> </ul> </li> <li>Go to http://127.0.0.1:8000/ and work with your <code>websocket</code></li> </ul> <p>Next Step: First CRUD</p>"},{"location":"#how-panther-works","title":"How Panther Works!","text":""},{"location":"#roadmap","title":"Roadmap","text":""},{"location":"authentications/","title":"Authentications","text":"<p>Variable: <code>AUTHENTICATION</code> &amp; <code>WS_AUTHENTICATION</code> </p> <p>Type: <code>str</code></p> <p>Default: <code>None</code></p> <p>You can set Authentication class in your <code>configs</code> </p> <p>Panther use it, to authenticate every API/ WS if <code>auth=True</code> and give you the user or <code>raise HTTP_401_UNAUTHORIZED</code></p> <p>The <code>user</code> will be in <code>request.user</code> in APIs and in <code>self.user</code> in WSs </p> <p>We implemented 2 built-in authentication classes which use <code>JWT</code> for authentication.</p> <p>But, You can use your own custom authentication class too.</p>"},{"location":"authentications/#jwtauthentication","title":"JWTAuthentication","text":"<p>This class will </p> <ul> <li>Get the <code>token</code> from <code>Authorization</code> header of request.</li> <li>Check the <code>Bearer</code></li> <li><code>decode</code> the <code>token</code> </li> <li>Find the matched <code>user</code></li> </ul> <p><code>JWTAuthentication</code> is going to use <code>panther.db.models.BaseUser</code> if you didn't set the <code>USER_MODEL</code> in your <code>configs</code></p> <p>You can customize these 4 variables for <code>JWTAuthentication</code> in your <code>configs</code> as <code>JWTConfig</code> like below (<code>JWTConfig</code> is optional):</p> <pre><code>...\nfrom datetime import timedelta\nfrom panther.utils import load_env  \nfrom pathlib import Path\n\nBASE_DIR = Path(__name__).resolve().parent  \nenv = load_env(BASE_DIR / '.env')\n\nSECRET_KEY = env['SECRET_KEY']\n\nJWTConfig = {  \n    'key': SECRET_KEY,  \n    'algorithm': 'HS256',  \n    'life_time': timedelta(days=2),  \n    'refresh_life_time': timedelta(days=10),  \n}\n</code></pre> <p>key \u2003\u2003\u2003\u2003--&gt; default is <code>SECRET_KEY</code></p> <p>algorithm \u2003 --&gt; default is <code>HS256</code></p> <p>life_time\u2003\u2003--&gt; default is <code>timedelta(days=1)</code> </p> <p>refresh_life_time\u2003\u2003--&gt; default is <code>multiply 2 of life_time</code> </p>"},{"location":"authentications/#queryparamjwtauthentication","title":"QueryParamJWTAuthentication","text":"<ul> <li> <p>This class is same as <code>JWTAuthentication</code> and the only difference is that, this class is looking for token in <code>query params</code> not in the <code>headers</code></p> </li> <li> <p>You should pass the token like this:</p> <p>https://example.com/path?authorization=Bearer%20access_token</p> </li> </ul>"},{"location":"authentications/#websocket-authentication","title":"Websocket Authentication","text":"<p>The <code>QueryParamJWTAuthentication</code> is very useful when you are trying to authenticate the user in websocket, you just have to add this into your <code>configs</code>: <pre><code>WS_AUTHENTICATION = 'panther.authentications.QueryParamJWTAuthentication'\n</code></pre></p>"},{"location":"authentications/#custom-authentication","title":"Custom Authentication","text":"<ul> <li> <p>Create a class and inherits it from <code>panther.authentications.BaseAuthentication</code></p> </li> <li> <p>Implement <code>async authentication(cls, request: Request | Websocket)</code> method</p> <ul> <li>Process the <code>request.headers.authorization</code> or ...</li> <li>Return Instance of <code>USER_MODEL</code></li> <li>Or raise <code>panther.exceptions.AuthenticationAPIError</code> </li> </ul> </li> <li> <p>Add it into your <code>configs</code> <pre><code>AUTHENTICATION = 'project_name.core.authentications.CustomAuthentication'\n</code></pre></p> </li> </ul> <p>You can see the source code of JWTAuthentication [here] </p>"},{"location":"background_tasks/","title":"Background Tasks","text":""},{"location":"background_tasks/#intro","title":"Intro","text":"<p>Panther is going to run the <code>background tasks</code> as a thread in the background on startup if you set the <code>BACKGROUND_TASKS</code> to <code>True</code></p>"},{"location":"background_tasks/#usage","title":"Usage","text":"<ul> <li> <p>Add the <code>BACKGROUND_TASKS = True</code> in the <code>configs</code> </p> </li> <li> <p>Import the <code>background_tasks</code> from <code>panther.background_tasks</code>:     <pre><code>from panther.background_tasks import background_tasks\n</code></pre></p> </li> <li> <p>Create a <code>task</code> <pre><code>from panther.background_tasks import background_tasks, BackgroundTask\n\ndef do_something(name: str, age: int):\n    pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26)\n</code></pre></p> </li> <li> <p>Now you can add your task to the <code>background_tasks</code> <pre><code>from panther.background_tasks import background_tasks, BackgroundTask\n\ndef do_something(name: str, age: int):\n    pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26)\nbackground_tasks.add_task(task)\n</code></pre></p> </li> </ul>"},{"location":"background_tasks/#options","title":"Options","text":"<ul> <li><code>every_seconds()</code></li> <li><code>every_minutes()</code> </li> <li><code>every_hours()</code> </li> <li><code>every_days()</code></li> <li><code>every_weeks()</code></li> <li><code>at()</code>  # Set Custom Time</li> <li> <p><code>on()</code>  # Set Custom Day Of Week</p> <p>You can pass your custom value to them too, </p> <p>Example: Run Every 4 days: <code>every_days(4)</code>.</p> </li> <li> </li> </ul> <p>let's say we want to run the <code>task</code> below every day on <code>8:00</code> o'clock. </p> <pre><code>from datetime import time\n\nfrom panther.background_tasks import BackgroundTask, background_tasks\n\n\ndef do_something(name: str, age: int):\n        pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26).every_days().at(time(hour=8))\nbackground_tasks.add_task(task)\n</code></pre> <ul> <li> </li> </ul> <pre><code>from datetime import time\n\nfrom panther.background_tasks import BackgroundTask, background_tasks\n\n\ndef do_something(name: str, age: int):\n        pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26).every_weeks(2).on('monday').at(time(hour=8))\nbackground_tasks.add_task(task)\n</code></pre>"},{"location":"background_tasks/#interval","title":"Interval","text":"<p>You can set custom <code>interval</code> for the <code>tasks</code>, let's say we want to run the <code>task</code> below for <code>3 times</code>.</p> <pre><code>from panther.background_tasks import BackgroundTask, background_tasks\n\n\ndef do_something(name: str, age: int):\n    pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26).interval(3)\nbackground_tasks.add_task(task)\n</code></pre>"},{"location":"background_tasks/#schedule","title":"Schedule","text":"<p><code>BackgroundTask</code> has some methods to <code>schedule</code> the run time, (Default value of them is <code>1</code>)</p>"},{"location":"background_tasks/#time-specification","title":"Time Specification","text":"<p>You can set a custom <code>time</code> to tasks too</p>"},{"location":"background_tasks/#day-of-week-specification","title":"Day Of Week Specification","text":"Now we want to run the <code>task</code> below every 2 week on <code>monday</code>, on <code>8:00</code> o'clock."},{"location":"background_tasks/#notice","title":"Notice","text":"<ul> <li> <p>The <code>task</code> function can be <code>sync</code> or <code>async</code></p> </li> <li> <p>You can pass the arguments to the task as <code>args</code> and <code>kwargs</code> </p> <pre><code>def do_something(name: str, age: int):\n        pass\n\ntask = BackgroundTask(do_something, name='Ali', age=26)\nor \ntask = BackgroundTask(do_something, 'Ali', age=26)\nor \ntask = BackgroundTask(do_something, 'Ali', 26)\n</code></pre> </li> <li> <p>Default of interval() is 1.</p> </li> <li> <p>The -1 interval means infinite, </p> </li> <li> <p>The <code>.at()</code> only useful when you are using <code>.every_days()</code> or <code>.every_weeks()</code></p> </li> <li> <p>The <code>.on()</code> only useful when you are using <code>.every_weeks()</code></p> </li> </ul>"},{"location":"class_first_crud/","title":"Class Base","text":"<p>We assume you could run the project with Introduction</p> <p>Now let's write custom APIs for <code>Create</code>, <code>Retrieve</code>, <code>Update</code> and <code>Delete</code> a <code>Book</code>:</p>"},{"location":"class_first_crud/#structure-requirements","title":"Structure &amp; Requirements","text":""},{"location":"class_first_crud/#create-model","title":"Create Model","text":"<p>Create a model named <code>Book</code> in <code>app/models.py</code>:</p> <pre><code>from panther.db import Model\n\n\nclass Book(Model):\n    name: str\n    author: str\n    pages_count: int\n</code></pre>"},{"location":"class_first_crud/#create-api-class","title":"Create API Class","text":"<p>Create the <code>BookAPI()</code> in <code>app/apis.py</code>:</p> <pre><code>from panther.app import GenericAPI\n\n\nclass BookAPI(GenericAPI):\n    ... \n</code></pre> <p>We are going to complete it later ...</p>"},{"location":"class_first_crud/#update-urls","title":"Update URLs","text":"<p>Add the <code>BookAPI</code> in <code>app/urls.py</code>:</p> <pre><code>from app.apis import BookAPI\n\n\nurls = {\n    'book/': BookAPI,\n}\n</code></pre> <p>We assume that the <code>urls</code> in <code>core/urls.py</code> pointing to <code>app/urls.py</code>, like below:</p> <pre><code>from app.urls import urls as app_urls\n\n\nurls = {\n    '/': app_urls,\n}\n</code></pre>"},{"location":"class_first_crud/#add-database","title":"Add Database","text":"<p>Add <code>DATABASE</code> in <code>configs</code>, we are going to add <code>pantherdb</code></p> <p>PantherDB is a Simple, File-Base and Document Oriented database</p> <pre><code>...\nDATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n    }\n}\n...\n</code></pre>"},{"location":"class_first_crud/#apis","title":"APIs","text":""},{"location":"class_first_crud/#api-create-a-book","title":"API - Create a Book","text":"<p>Now we are going to create a book on <code>post</code> request, We need to:</p> <ol> <li> <p>Declare <code>post</code> method in <code>BookAPI</code>:     <pre><code>from panther.app import GenericAPI\n\n\nclass BookAPI(GenericAPI):\n\n    async def post(self):\n        ...\n</code></pre></p> </li> <li> <p>Declare <code>request: Request</code> in <code>BookAPI.post()</code> function:     <pre><code>from panther.app import GenericAPI\nfrom panther.request import Request\n\n\nclass BookAPI(GenericAPI):\n\n    async def post(self, request: Request):\n        ...\n</code></pre></p> </li> <li> <p>Create serializer in <code>app/serializers.py</code>, we used <code>pydantic</code> for the <code>validation</code> of <code>request.data</code> :     <pre><code>from pydantic import BaseModel\n\n\nclass BookSerializer(BaseModel):\n    name: str\n    author: str\n    pages_count: int\n</code></pre></p> </li> <li> <p>Pass the created serializer to our <code>BookAPI</code> as <code>input_model</code> so the incoming data will be validated and cleaned automatically:</p> <p><pre><code>from panther.app import GenericAPI\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        ...\n</code></pre>    Now we have access to <code>request.data</code>, We are going to use it like the below for ease of use, so the auto-suggest helps us in development:</p> <pre><code>from panther.app import GenericAPI\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        body: BookSerializer = request.validated_data\n        ...\n</code></pre> </li> <li> <p>Now we have access to the validated data, and we can create our first book:</p> <pre><code>from panther.app import GenericAPI\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        body: BookSerializer = request.validated_data\n        await Book.insert_one(\n            name=body.name,\n            author=body.author,\n            pages_count=body.pages_count,\n        )\n        ...\n</code></pre> </li> <li> <p>And finally we return <code>201 Created</code> status_code as response of <code>post</code>:     <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        body: BookSerializer = request.validated_data\n        book = await Book.insert_one(\n            name=body.name,\n            author=body.author,\n            pages_count=body.pages_count,\n        )\n        return Response(data=book, status_code=status.HTTP_201_CREATED)\n</code></pre></p> </li> </ol> <p>The response.data can be <code>Instance of Models</code>, <code>dict</code>, <code>str</code>, <code>tuple</code>, <code>list</code>, <code>str</code> or <code>None</code></p> <p>Panther will return <code>None</code> if you don't return anything as response.</p>"},{"location":"class_first_crud/#api-list-of-books","title":"API - List of Books","text":"<p>We just need to add another method for <code>GET</code> method and return the lists of books:</p> <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        ...\n\n    async def get(self):\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre> <p>Panther validate input with <code>input_model</code>, only in <code>POST</code>, <code>PUT</code>, <code>PATCH</code> methods.</p>"},{"location":"class_first_crud/#filter-response-fields","title":"Filter Response Fields","text":"<p>Assume we don't want to return field <code>author</code> in response:</p> <ol> <li> <p>Create new serializer in <code>app/serializers.py</code>:</p> <pre><code>from pydantic import BaseModel\n\n\nclass BookOutputSerializer(BaseModel):\n    name: str\n    pages_count: int\n</code></pre> </li> <li> <p>Add the <code>BookOutputSerializer</code> as <code>output_model</code> to your <code>class</code></p> <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n    output_model = BookOutputSerializer\n\n    async def post(self, request: Request):\n        ...\n\n    async def get(self):\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre> </li> </ol> <p>Panther use the <code>output_model</code>, in all methods.</p>"},{"location":"class_first_crud/#cache-the-response","title":"Cache The Response","text":"<p>For caching the response, we should add <code>cache=True</code> in <code>API()</code>. And it will return the cached response every time till <code>cache_exp_time</code></p> <p>For setting a custom expiration time for API we need to add <code>cache_exp_time</code> to <code>API()</code>:</p> <pre><code>from datetime import timedelta\n\nfrom panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n    output_model = BookOutputSerializer\n    cache = True\n    cache_exp_time = timedelta(seconds=10)\n\n    async def post(self, request: Request):\n        ...\n\n    async def get(self):\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre> <p>Panther is going to use the <code>DEFAULT_CACHE_EXP</code> from <code>core/configs.py</code> if <code>cache_exp_time</code> has not been set.</p>"},{"location":"class_first_crud/#throttle-the-request","title":"Throttle The Request","text":"<p>For setting rate limit for requests, we can add throttling to <code>BookAPI</code>, it should be the instance of <code>panther.throttling.Throttling</code>, something like below (in the below example user can't request more than 10 times in a minutes):</p> <pre><code>from datetime import timedelta\n\nfrom panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\nfrom panther.throttling import Throttling\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n    output_model = BookOutputSerializer\n    cache = True\n    cache_exp_time = timedelta(seconds=10)\n    throttling = Throttling(rate=10, duration=timedelta(minutes=1))\n\n    async def post(self, request: Request):\n        ...\n\n    async def get(self):\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre>"},{"location":"class_first_crud/#api-retrieve-a-book","title":"API - Retrieve a Book","text":"<p>For <code>retrieve</code>, <code>update</code> and <code>delete</code> API, we are going to</p> <ol> <li> <p>Create another class named <code>SingleBookAPI</code> in <code>app/apis.py</code>:</p> <pre><code>from panther.app import GenericAPI\n\n\nclass SingleBookAPI(GenericAPI):\n    ...\n</code></pre> </li> <li> <p>Add it in <code>app/urls.py</code>:</p> <pre><code>from app.apis import BookAPI, SingleBookAPI\n\n\nurls = {\n    'book/': BookAPI,\n    'book/&lt;book_id&gt;/': SingleBookAPI,\n}\n</code></pre> </li> </ol> <p>You should write the Path Variable in <code>&lt;</code> and <code>&gt;</code></p> <p>You should have the parameter with the same name of <code>path variable</code> in you <code>api</code> with normal <code>type hints</code></p> <p>Panther will convert type of the <code>path variable</code> to your parameter type, then pass it</p> <ol> <li> <p>Complete the api:</p> <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\nclass SingleBookAPI(GenericAPI):\n\n    async def get(self, book_id: int):\n        if book := await Book.find_one(id=book_id):\n            return Response(data=book, status_code=status.HTTP_200_OK)\n        else:\n            return Response(status_code=status.HTTP_404_NOT_FOUND)\n</code></pre> </li> </ol>"},{"location":"class_first_crud/#api-update-a-book","title":"API - Update a Book","text":"<p>Add another method named <code>put()</code> for <code>PUT</code> method and update the book you want:</p> <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\nclass SingleBookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def get(self, book_id: int):\n        ...\n\n    async def put(self, request: Request, book_id: int):\n        is_updated: bool = await Book.update_one({'id': book_id}, request.validated_data.model_dump())\n        data = {'is_updated': is_updated}\n        return Response(data=data, status_code=status.HTTP_202_ACCEPTED)\n</code></pre> <p>You can handle the PATCH the same way as PUT</p>"},{"location":"class_first_crud/#api-delete-a-book","title":"API - Delete a Book","text":"<p>Add another method named <code>delete()</code> for <code>DELETE</code> method and delete the book you want:</p> <pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\n\nclass SingleBookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def get(self, book_id: int):\n        ...\n\n    async def put(self, request: Request, book_id: int):\n        ...\n\n    async def delete(self, book_id: int):\n        is_deleted: bool = await Book.delete_one(id=book_id)\n        if is_deleted:\n            return Response(status_code=status.HTTP_204_NO_CONTENT)\n        else:\n            return Response(status_code=status.HTTP_400_BAD_REQUEST)\n</code></pre>"},{"location":"configs/","title":"Configs","text":"<p>Panther collect all the configs from your <code>core/configs.py</code> or the module you passed directly to <code>Panther(configs=__name__)</code></p>"},{"location":"configs/#monitoring","title":"MONITORING","text":"<p>Type: <code>bool</code> (Default: <code>False</code>)</p> <p>It should be <code>True</code> if you want to use <code>panther monitor</code> command and watch the monitoring</p> <p>If <code>True</code>:</p> <ul> <li>Log every request in <code>logs/monitoring.log</code></li> </ul> <p>Requires watchfiles package.</p>"},{"location":"configs/#log_queries","title":"LOG_QUERIES","text":"<p>Type: <code>bool</code> (Default: <code>False</code>)</p> <p>If <code>True</code>:</p> <ul> <li>Calculate every query <code>perf time</code> &amp; Log them in <code>logs/query.log</code></li> </ul>"},{"location":"configs/#middlewares","title":"MIDDLEWARES","text":"<p>Type: <code>list</code> (Default: <code>[ ]</code>)</p> <p>List of middlewares you want to use</p>"},{"location":"configs/#authentication","title":"AUTHENTICATION","text":"<p>Type: <code>str | None</code> (Default: <code>None</code>)</p> <p>Every request goes through <code>authentication()</code> method of this <code>class</code> (if <code>auth = True</code>)</p> <p>Requires python-jose package.</p> <p>Example: <code>AUTHENTICATION = 'panther.authentications.JWTAuthentication'</code></p>"},{"location":"configs/#ws_authentication","title":"WS_AUTHENTICATION","text":"<p>Type: <code>str | None</code> (Default: <code>None</code>)</p> <p>WebSocket requests goes through <code>authentication()</code> method of this <code>class</code>, before the <code>connect()</code> (if <code>auth = True</code>)</p> <p>Example: <code>WS_AUTHENTICATION = 'panther.authentications.QueryParamJWTAuthentication'</code></p>"},{"location":"configs/#urls","title":"URLs","text":"<p>Type: <code>str</code> (Required)</p> <p>It can be optional if you pass your <code>urls</code> directly to <code>Panther(urls=url_routing)</code></p> <p>It should be the address of your <code>urls</code> <code>dict</code></p> <p>Example: <code>URLs = 'core.configs.urls.url_routing'</code></p>"},{"location":"configs/#default_cache_exp","title":"DEFAULT_CACHE_EXP","text":"<p>Type: <code>timedelta| None</code> (Default: <code>None</code>)</p> <p>We use it as default <code>cache_exp_time</code> you can overwrite it in your <code>@API</code> too</p> <p>It is used when you set <code>cache=True</code> in <code>@API</code> decorator</p> <p>Example: <code>DEFAULT_CACHE_EXP = timedelta(seconds=10)</code></p>"},{"location":"configs/#templates_dir","title":"TEMPLATES_DIR","text":"<p>Type: <code>str | list[str]</code> (Default: <code>'tempaltes'</code>)</p> <p>We use it when want to have different template directories</p> <p>Example: `TEMPLATES_DIR = ['templates', 'app/templates']</p>"},{"location":"configs/#throttling","title":"THROTTLING","text":"<p>Type: <code>Throttling | None</code> (Default: <code>None</code>)</p> <p>We use it as default <code>throttling</code> you can overwrite it in your <code>@API</code> too</p> <p>Example: <code>THROTTLING = Throttling(rate=10, duration=timedelta(seconds=10))</code></p>"},{"location":"configs/#user_model","title":"USER_MODEL","text":"<p>Type: <code>str | None</code> (Default: <code>'panther.db.models.BaseUser'</code>)</p> <p>It is used for authentication</p> <p>Example: <code>USER_MODEL = 'panther.db.models.User'</code></p>"},{"location":"configs/#jwtconfig","title":"JWTConfig","text":"<p>Type: <code>dict | None</code> (Default: <code>JWTConfig = {'key': SECRET_KEY}</code>)</p> <p>We use it when you set <code>panther.authentications.JWTAuthentication</code> as <code>AUTHENTICATION</code></p>"},{"location":"configs/#background_tasks","title":"BACKGROUND_TASKS","text":"<p>Type: <code>bool</code> (Default: <code>False</code>)</p> <p>If <code>True</code>:</p> <ul> <li><code>initialize()</code> the <code>background_tasks</code></li> </ul>"},{"location":"configs/#startup","title":"STARTUP","text":"<p>Type: <code>str | None</code> (Default: <code>None</code>)</p> <p>It should be dotted address of your <code>startup</code> function, this function can be <code>sync</code> or <code>async</code></p> <p>Example: <code>STARTUP = 'core.configs.startup'</code></p>"},{"location":"configs/#shutdown","title":"SHUTDOWN","text":"<p>Type: <code>str | None</code> (Default: <code>None</code>)</p> <p>It should be dotted address of your <code>shutdown</code> function this function can be <code>sync</code> or <code>async</code></p> <p>Example: <code>SHUTDOWN = 'core.configs.shutdown'</code></p>"},{"location":"configs/#auto_reformat","title":"AUTO_REFORMAT","text":"<p>Type: <code>bool</code> (Default: <code>False</code>)</p> <p>It will reformat your code on every reload (on every change if you run the project with <code>--reload</code>) </p> <p>You may want to write your custom <code>ruff.toml</code> in root of your project.</p> <p>Requires ruff package.</p> <p>Reference: https://docs.astral.sh/ruff/formatter/</p> <p>Example: <code>AUTO_REFORMAT = True</code></p>"},{"location":"configs/#database","title":"DATABASE","text":"<p>Type: <code>dict</code> (Default: <code>{}</code>)</p> <p>We use it to create <code>database</code> connection</p>"},{"location":"configs/#redis","title":"REDIS","text":"<p>Type: <code>dict</code> (Default: <code>{}</code>)</p> <p>Requires redis package.</p> <p>We use it to create <code>redis</code> connection</p>"},{"location":"configs/#timezone","title":"TIMEZONE","text":"<p>Type: <code>str</code> (Default: <code>'UTC'</code>)</p> <p>Used in <code>panther.utils.timezone_now()</code> which returns a <code>datetime</code> based on your <code>timezone</code></p> <p>And <code>panther.utils.timezone_now()</code> used in <code>BaseUser.date_created</code> and <code>BaseUser.last_login</code> </p>"},{"location":"database/","title":"Database","text":"<p>Panther currently built-in supports 2 database (<code>MongoDB</code>, <code>PantherDB</code>), but you can define your own custom database connection and queries too.</p>"},{"location":"database/#structure","title":"Structure","text":"<pre><code>DATABASE = {\n    'engine': {\n        'class': 'address of engine',\n        'arg1': 'value1',\n        ...\n    },\n    'query': 'address of query class'\n}\n</code></pre>"},{"location":"database/#notes","title":"Notes","text":"<ul> <li>Built-in supported engines:</li> <li><code>panther.db.connections.PantherDBConnection</code></li> <li><code>panther.db.connections.MongoDBConnection</code></li> <li><code>engine</code> values, other than the <code>class</code> will be passed to the <code>class.__init__()</code> </li> <li><code>query</code> is not required when you are using default supported engines, but you can customize it</li> </ul>"},{"location":"database/#pantherdb","title":"PantherDB","text":"<pre><code>DATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n        'path': BASE_DIR / 'database.pdb',\n        'encryption': True\n    }\n}\n</code></pre>"},{"location":"database/#notes_1","title":"Notes","text":"<ul> <li><code>path</code> is not required, but you can customize the directory and file of your database</li> <li><code>encryption</code> is not required and default is <code>False</code></li> <li>The <code>cryptography</code> package is required if you set <code>encryption</code> to <code>True</code></li> </ul>"},{"location":"database/#mongodb","title":"MongoDB","text":"<pre><code>DATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.MongoDBConnection',\n        'host': 'mongodb://127.0.0.1:27017/database_name'\n    }\n}\n</code></pre>"},{"location":"database/#notes_2","title":"Notes","text":"<ul> <li>The parameters are same as <code>pymongo.MongoClient</code> [Reference]</li> </ul>"},{"location":"database/#how-it-works","title":"How it works?","text":"<ul> <li> <p>Panther creates a database connection depends on <code>DATABASE</code> block you defined in <code>configs</code></p> </li> <li> <p>You can access to this connection with your <code>models</code>, or direct access from <code>from panther.db.connections import db</code></p> </li> <li> <p>Now we are going to create a new API which uses <code>PantherDB</code> and creating a <code>Book</code></p> </li> <li> <p>Create <code>Book</code> model in <code>app/models.py</code> <pre><code>from panther.db import Model\n\n\nclass Book(Model):\n    title: str\n    description: str\n    pages_count: int\n</code></pre></p> </li> <li> <p>Add <code>book</code> url in <code>app/urls.py</code> that points to <code>book_api()</code></p> <pre><code>...\nfrom app.apis import book_api\n\n\nurls = {\n    'book/': book_api,\n}\n</code></pre> </li> <li> <p>Create <code>book_api()</code> in <code>app/apis.py</code></p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.response import Response\n\n\n@API()\nasync def book_api():\n    ...\n    return Response(status_code=status.HTTP_201_CREATED)  \n</code></pre> </li> <li> <p>Now we should use the Panther ODM to create a book, it's based on mongo queries, for creation we use <code>insert_one</code> like this:</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.response import Response\nfrom app.models import Book\n\n\n@API()\nasync def book_api():\n    Book.insert_one(\n        title='Python',\n        description='Python is good.',\n        pages_count=10\n    )\n    return Response(status_code=status.HTTP_201_CREATED)  \n</code></pre> </li> </ul> <p>In next step we are going to explain more about <code>Panther ODM</code></p>"},{"location":"events/","title":"Events","text":""},{"location":"events/#startup-event","title":"Startup Event","text":"<p>Use <code>Event.startup</code> decorator</p> <pre><code>from panther.events import Event\n\n\n@Event.startup\ndef do_something_on_startup():\n    print('Hello, I am at startup')\n</code></pre>"},{"location":"events/#shutdown-event","title":"Shutdown Event","text":"<pre><code>from panther.events import Event\n\n\n@Event.shutdown\ndef do_something_on_shutdown():\n    print('Good Bye, I am at shutdown')\n</code></pre>"},{"location":"events/#notice","title":"Notice","text":"<ul> <li>You can have multiple events on <code>startup</code> and <code>shutdown</code></li> <li>Events can be <code>sync</code> or <code>async</code></li> </ul>"},{"location":"function_first_crud/","title":"Function Base","text":"<p>We assume you could run the project with Introduction</p> <p>Now let's write custom APIs for <code>Create</code>, <code>Retrieve</code>, <code>Update</code> and <code>Delete</code> a <code>Book</code>:</p>"},{"location":"function_first_crud/#structure-requirements","title":"Structure &amp; Requirements","text":""},{"location":"function_first_crud/#create-model","title":"Create Model","text":"<p>Create a model named <code>Book</code> in <code>app/models.py</code>:</p> <pre><code>from panther.db import Model\n\n\nclass Book(Model):\n    name: str\n    author: str\n    pages_count: int\n</code></pre>"},{"location":"function_first_crud/#create-api-function","title":"Create API Function","text":"<p>Create the <code>book_api()</code> in <code>app/apis.py</code>:</p> <pre><code>from panther.app import API\n\n\n@API()\nasync def book_api():\n    ... \n</code></pre> <p>We are going to complete it later ...</p>"},{"location":"function_first_crud/#update-urls","title":"Update URLs","text":"<p>Add the <code>book_api</code> in <code>app/urls.py</code>:</p> <pre><code>from app.apis import book_api\n\n\nurls = {\n    'book/': book_api,\n}\n</code></pre> <p>We assume that the <code>urls</code> in <code>core/urls.py</code> pointing to <code>app/urls.py</code>, like below:</p> <pre><code>from app.urls import urls as app_urls\n\n\nurls = {\n    '/': app_urls,\n}\n</code></pre>"},{"location":"function_first_crud/#add-database","title":"Add Database","text":"<p>Add <code>DATABASE</code> in <code>configs</code>, we are going to add <code>pantherdb</code></p> <p>PantherDB is a Simple, File-Base and Document Oriented database</p> <pre><code>...\nDATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n    }\n}\n...\n</code></pre>"},{"location":"function_first_crud/#apis","title":"APIs","text":""},{"location":"function_first_crud/#api-create-a-book","title":"API - Create a Book","text":"<p>Now we are going to create a book on <code>post</code> request, We need to:</p> <ol> <li> <p>Declare <code>request: Request</code> in <code>book_api</code> function:     <pre><code>from panther.app import API\nfrom panther.request import Request\n\n\n@API()\nasync def book_api(request: Request):\n    ...\n</code></pre></p> </li> <li> <p>Create serializer in <code>app/serializers.py</code>, we used <code>pydantic</code> for the <code>validation</code> of <code>request.data</code> :     <pre><code>from pydantic import BaseModel\n\n\nclass BookSerializer(BaseModel):\n    name: str\n    author: str\n    pages_count: int\n</code></pre></p> </li> <li> <p>Pass the created serializer to our <code>book_api</code> as <code>input_model</code> so the incoming data will be validated and cleaned automatically:</p> <p><pre><code>from panther.app import API\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    ...\n</code></pre>    Now we have access to <code>request.data</code>, We are going to use it like the below for ease of use, so the auto-suggest helps us in development:</p> <pre><code>from panther.app import API\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    body: BookSerializer = request.validated_data\n    ...\n</code></pre> </li> <li> <p>Now we have access to the validated data, and we can create our first book:</p> <pre><code>from panther.app import API\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    body: BookSerializer = request.validated_data\n\n    await Book.insert_one(\n        name=body.name,\n        author=body.author,\n        pages_count=body.pages_count,\n    )\n    ...\n</code></pre> </li> <li> <p>But we only want this happens in <code>post</code> requests, so we add this <code>condition</code>:</p> <pre><code>from panther.app import API\nfrom panther.request import Request\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        body: BookSerializer = request.validated_data\n\n        await Book.insert_one(\n            name=body.name,\n            author=body.author,\n            pages_count=body.pages_count,\n        )\n        ...\n</code></pre> </li> <li> <p>And finally we return <code>201 Created</code> status_code as response of <code>post</code> and <code>501 Not Implemented</code> for other methods:     <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        body: BookSerializer = request.validated_data\n\n        book: Book = await Book.insert_one(\n            name=body.name,\n            author=body.author,\n            pages_count=body.pages_count,\n        )\n        return Response(data=book, status_code=status.HTTP_201_CREATED)\n\n    return Response(status_code=status.HTTP_501_NOT_IMPLEMENTED)\n</code></pre></p> </li> </ol> <p>The response.data can be <code>Instance of Models</code>, <code>dict</code>, <code>str</code>, <code>tuple</code>, <code>list</code>, <code>str</code> or <code>None</code></p> <p>Panther will return <code>None</code> if you don't return anything as response.</p>"},{"location":"function_first_crud/#api-list-of-books","title":"API - List of Books","text":"<p>We just need to add another condition on <code>GET</code> methods and return the lists of books:</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer)\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        ...\n\n    elif request.method == 'GET':\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n\n    return Response(status_code=status.HTTP_501_NOT_IMPLEMENTED)\n</code></pre> <p>Panther validate input with <code>input_model</code>, only in <code>POST</code>, <code>PUT</code>, <code>PATCH</code> methods.</p>"},{"location":"function_first_crud/#filter-response-fields","title":"Filter Response Fields","text":"<p>Assume we don't want to return field <code>author</code> in response:</p> <ol> <li> <p>Create new serializer in <code>app/serializers.py</code>:</p> <pre><code>from pydantic import BaseModel\n\n\nclass BookOutputSerializer(BaseModel):\n    name: str\n    pages_count: int\n</code></pre> </li> <li> <p>Add the <code>BookOutputSerializer</code> as <code>output_model</code> to your <code>API()</code> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer, output_model=BookOutputSerializer)\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        ...\n\n    elif request.method == 'GET':\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n\n    return Response(status_code=status.HTTP_501_NOT_IMPLEMENTED)\n</code></pre></p> </li> </ol> <p>Panther use the <code>output_model</code>, in all methods.</p>"},{"location":"function_first_crud/#cache-the-response","title":"Cache The Response","text":"<p>For caching the response, we should add <code>cache=True</code> in <code>API()</code>. And it will return the cached response every time till <code>cache_exp_time</code></p> <p>For setting a custom expiration time for API we need to add <code>cache_exp_time</code> to <code>API()</code>:</p> <pre><code>from datetime import timedelta\n\nfrom panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer, output_model=BookOutputSerializer, cache=True, cache_exp_time=timedelta(seconds=10))\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        ...\n\n    elif request.method == 'GET':\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n\n    return Response(status_code=status.HTTP_501_NOT_IMPLEMENTED)\n</code></pre> <p>Panther is going to use the <code>DEFAULT_CACHE_EXP</code> from <code>core/configs.py</code> if <code>cache_exp_time</code> has not been set.</p>"},{"location":"function_first_crud/#throttle-the-request","title":"Throttle The Request","text":"<p>For setting rate limit for requests, we can add throttling to <code>API()</code>, it should be the instance of <code>panther.throttling.Throttling</code>, something like below (in the below example user can't request more than 10 times in a minutes):</p> <pre><code>from datetime import timedelta\n\nfrom panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\nfrom panther.throttling import Throttling\n\nfrom app.serializers import BookSerializer, BookOutputSerializer\nfrom app.models import Book\n\n\n@API(\n    input_model=BookSerializer, \n    output_model=BookOutputSerializer, \n    cache=True, \n    cache_exp_time=timedelta(seconds=10),\n    throttling=Throttling(rate=10, duration=timedelta(minutes=1))\n)\nasync def book_api(request: Request):\n    if request.method == 'POST':\n        ...\n\n    elif request.method == 'GET':\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n\n    return Response(status_code=status.HTTP_501_NOT_IMPLEMENTED)\n</code></pre>"},{"location":"function_first_crud/#api-retrieve-a-book","title":"API - Retrieve a Book","text":"<p>For <code>retrieve</code>, <code>update</code> and <code>delete</code> API, we are going to</p> <ol> <li> <p>Create another api named <code>single_book_api</code> in <code>app/apis.py</code>:</p> <pre><code>from panther.app import API\nfrom panther.request import Request\n\n\n@API()\nasync def single_book_api(request: Request):\n    ...\n</code></pre> </li> <li> <p>Add it in <code>app/urls.py</code>:</p> <pre><code>from app.apis import book_api, single_book_api\n\n\nurls = {\n    'book/': book_api,\n    'book/&lt;book_id&gt;/': single_book_api,\n}\n</code></pre> </li> </ol> <p>You should write the Path Variable in <code>&lt;</code> and <code>&gt;</code></p> <p>You should have the parameter with the same name of <code>path variable</code> in you <code>api</code> with normal <code>type hints</code></p> <p>Panther will convert type of the <code>path variable</code> to your parameter type, then pass it</p> <ol> <li> <p>Complete the api:</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\n@API()\nasync def single_book_api(request: Request, book_id: int):\n    if request.method == 'GET':\n        if book := await Book.find_one(id=book_id):\n            return Response(data=book, status_code=status.HTTP_200_OK)\n        else:\n            return Response(status_code=status.HTTP_404_NOT_FOUND)\n</code></pre> </li> </ol>"},{"location":"function_first_crud/#api-update-a-book","title":"API - Update a Book","text":"<ul> <li> <p>We can update in several ways:</p> <ol> <li> <p>Update a document</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\n@API(input_model=BookSerializer)\nasync def single_book_api(request: Request, book_id: int):\n    body: BookSerializer = request.validated_data\n    if request.method == 'GET':\n        ...\n    elif request.method == 'PUT':\n        book: Book = await Book.find_one(id=book_id)\n        await book.update(\n            name=body.name, \n            author=body.author, \n            pages_count=body.pages_count\n        )\n        return Response(status_code=status.HTTP_202_ACCEPTED)\n</code></pre> </li> <li> <p>Update with <code>update_one</code> query</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\n@API(input_model=BookSerializer)\nasync def single_book_api(request: Request, book_id: int):\n    if request.method == 'GET':\n        ...\n    elif request.method == 'PUT':\n        is_updated: bool = await Book.update_one({'id': book_id}, request.validated_data.model_dump())\n        data = {'is_updated': is_updated}\n        return Response(data=data, status_code=status.HTTP_202_ACCEPTED)\n</code></pre> </li> <li> <p>Update with <code>update_many</code> query</p> <pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\n@API(input_model=BookSerializer)\nasync def single_book_api(request: Request, book_id: int):\n    if request.method == 'GET':\n        ...\n    elif request.method == 'PUT':\n        updated_count: int = await Book.update_many({'id': book_id}, request.validated_data.model_dump())\n        data = {'updated_count': updated_count}\n        return Response(data=data, status_code=status.HTTP_202_ACCEPTED)\n</code></pre> </li> </ol> <p>You can handle the PATCH the same way as PUT</p> </li> </ul>"},{"location":"function_first_crud/#api-delete-a-book","title":"API - Delete a Book","text":"<ul> <li> <p>We can delete in several ways too:</p> <ol> <li> <p>Delete a document</p> <p><pre><code>    from panther import status\n    from panther.app import API\n    from panther.request import Request\n    from panther.response import Response\n\n    from app.models import Book\n\n\n    @API()\n    async def single_book_api(request: Request, book_id: int):\n        if request.method == 'GET':\n            ...\n        elif request.method == 'PUT':\n            ...\n        elif request.method == 'DELETE':\n            is_deleted: bool = await Book.delete_one(id=book_id)\n            if is_deleted:\n                return Response(status_code=status.HTTP_204_NO_CONTENT)\n            else:\n                return Response(status_code=status.HTTP_400_BAD_REQUEST)\n</code></pre>     2. Delete with <code>delete_one</code> query</p> <pre><code>    from panther import status\n    from panther.app import API\n    from panther.request import Request\n    from panther.response import Response\n\n    from app.models import Book\n\n\n    @API()\n    async def single_book_api(request: Request, book_id: int):\n        if request.method == 'GET':\n            ...\n        elif request.method == 'PUT':\n            ...\n        elif request.method == 'DELETE':\n            is_deleted: bool = await Book.delete_one(id=book_id)\n            return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre> </li> <li> <p>Delete with <code>delete_many</code> query</p> <pre><code>    from panther import status\n    from panther.app import API\n    from panther.request import Request\n    from panther.response import Response\n\n    from app.models import Book\n\n\n    @API()\n    async def single_book_api(request: Request, book_id: int):\n        if request.method == 'GET':\n            ...\n        elif request.method == 'PUT':\n            ...\n        elif request.method == 'DELETE':\n            deleted_count: int = await Book.delete_many(id=book_id)\n            return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre> </li> </ol> </li> </ul>"},{"location":"generic_crud/","title":"Generic","text":"<p>We assume you could run the project with Introduction</p> <p>Now let's write custom APIs for <code>Create</code>, <code>Retrieve</code>, <code>Update</code> and <code>Delete</code> a <code>Book</code>:</p>"},{"location":"generic_crud/#structure-requirements","title":"Structure &amp; Requirements","text":""},{"location":"generic_crud/#create-model","title":"Create Model","text":"<p>Create a model named <code>Book</code> in <code>app/models.py</code>:</p> <pre><code>from panther.db import Model\n\n\nclass Book(Model):\n    name: str\n    author: str\n    pages_count: int\n</code></pre>"},{"location":"generic_crud/#create-api-class","title":"Create API Class","text":"<p>Create the <code>BookAPI()</code> in <code>app/apis.py</code>:</p> <pre><code>from panther.app import GenericAPI\n\n\nclass BookAPI(GenericAPI):\n    ... \n</code></pre> <p>We are going to complete it later ...</p>"},{"location":"generic_crud/#update-urls","title":"Update URLs","text":"<p>Add the <code>BookAPI</code> in <code>app/urls.py</code>:</p> <pre><code>from app.apis import BookAPI\n\n\nurls = {\n    'book/': BookAPI,\n}\n</code></pre> <p>We assume that the <code>urls</code> in <code>core/urls.py</code> pointing to <code>app/urls.py</code>, like below:</p> <pre><code>from app.urls import urls as app_urls\n\n\nurls = {\n    '/': app_urls,\n}\n</code></pre>"},{"location":"generic_crud/#add-database","title":"Add Database","text":"<p>Add <code>DATABASE</code> in <code>configs</code>, we are going to add <code>pantherdb</code></p> <p>PantherDB is a Simple, File-Base and Document Oriented database</p> <pre><code>...\nDATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n    }\n}\n...\n</code></pre>"},{"location":"generic_crud/#apis","title":"APIs","text":""},{"location":"generic_crud/#api-create-a-book","title":"API - Create a Book","text":"<p>Now we are going to create a book on <code>POST</code> request, we need to:</p> <ol> <li> <p>Inherit from <code>CreateAPI</code>:     <pre><code>from panther.generics import CreateAPI\n\n\nclass BookAPI(CreateAPI):\n    ...\n</code></pre></p> </li> <li> <p>Create a ModelSerializer in <code>app/serializers.py</code>, for <code>validation</code> of the <code>request.data</code>:</p> <pre><code>from panther.serializer import ModelSerializer\nfrom app.models import Book\n\nclass BookSerializer(ModelSerializer):\n    class Config:\n        model = Book\n        fields = ['name', 'author', 'pages_count']\n</code></pre> </li> <li> <p>Set the created serializer in <code>BookAPI</code> as <code>input_model</code>:</p> <pre><code>from panther.app import CreateAPI\nfrom app.serializers import BookSerializer\n\n\nclass BookAPI(CreateAPI):\n    input_model = BookSerializer\n</code></pre> </li> </ol> <p>It is going to create a <code>Book</code> with incoming <code>request.data</code> and return that instance to user with status code of <code>201</code></p>"},{"location":"generic_crud/#api-list-of-books","title":"API - List of Books","text":"<p>Let's return list of books of <code>GET</code> method, we need to:</p> <ol> <li> <p>Inherit from <code>ListAPI</code> <pre><code>from panther.generics import CreateAPI, ListAPI\nfrom app.serializers import BookSerializer\n\nclass BookAPI(CreateAPI, ListAPI):\n    input_model = BookSerializer\n    ...\n</code></pre></p> </li> <li> <p>define <code>cursor</code> method, so the <code>ListAPI</code> knows to return which books</p> <pre><code>from panther.generics import CreateAPI, ListAPI\nfrom panther.request import Request\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\nclass BookAPI(CreateAPI, ListAPI):\n    input_model = BookSerializer\n\n    async def cursor(self, request: Request, **kwargs):\n        return await Book.find()\n</code></pre> </li> </ol>"},{"location":"generic_crud/#pagination-search-filter-sort","title":"Pagination, Search, Filter, Sort","text":""},{"location":"generic_crud/#pagination","title":"Pagination","text":"<p>Use <code>panther.pagination.Pagination</code> as <code>pagination</code></p> <p>Usage: It will look for the <code>limit</code> and <code>skip</code> in the <code>query params</code> and return its own response template</p> <p>Example: <code>?limit=10&amp;skip=20</code></p>"},{"location":"generic_crud/#search","title":"Search","text":"<p>Define the fields you want the search, query on them in <code>search_fields</code> </p> <p>The value of <code>search_fields</code> should be <code>list</code></p> <p>Usage: It works with <code>search</code> query param --&gt; <code>?search=maybe_name_of_the_book_or_author</code></p> <p>Example: <code>?search=maybe_name_of_the_book_or_author</code></p>"},{"location":"generic_crud/#filter","title":"Filter","text":"<p>Define the fields you want to be filterable in <code>filter_fields</code> </p> <p>The value of <code>filter_fields</code> should be <code>list</code></p> <p>Usage: It will look for each value of the <code>filter_fields</code> in the <code>query params</code> and query on them</p> <p>Example: <code>?name=name_of_the_book&amp;author=author_of_the_book</code></p>"},{"location":"generic_crud/#sort","title":"Sort","text":"<p>Define the fields you want to be sortable in <code>sort_fields</code> </p> <p>The value of <code>sort_fields</code> should be <code>list</code></p> <p>Usage: It will look for each value of the <code>sort_fields</code> in the <code>query params</code> and sort with them</p> <p>Example: <code>?sort=pages_count,-name</code></p> <p>Notice:    - fields should be separated with a column <code>,</code>    - use <code>field_name</code> for ascending sort    - use <code>-field_name</code> for descending sort</p>"},{"location":"generic_crud/#example","title":"Example","text":"<pre><code>from panther.generics import CreateAPI, ListAPI\nfrom panther.pagination import Pagination\nfrom panther.request import Request\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer, BookOutputSerializer\n\nclass BookAPI(CreateAPI, ListAPI):\n    input_model = BookSerializer\n    output_model = BookOutputSerializer\n    pagination = Pagination\n    search_fields = ['name', 'author']\n    filter_fields = ['name', 'author']\n    sort_fields = ['name', 'pages_count']\n\n    async def cursor(self, request: Request, **kwargs):\n        return await Book.find()\n</code></pre>"},{"location":"generic_crud/#api-retrieve-a-book","title":"API - Retrieve a Book","text":"<p>Now we are going to retrieve a book on <code>GET</code> request, we need to:</p> <ol> <li> <p>Inherit from <code>RetrieveAPI</code>:     <pre><code>from panther.generics import RetrieveAPI\n\n\nclass SingleBookAPI(RetrieveAPI):\n    ...\n</code></pre></p> </li> <li> <p>define <code>object</code> method, so the <code>RetrieveAPI</code> knows to return which book</p> <pre><code>from panther.generics import RetrieveAPI\nfrom panther.request import Request\nfrom app.models import Book\n\n\nclass SingleBookAPI(RetrieveAPI):\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre> </li> <li> <p>Add it in <code>app/urls.py</code>:</p> <pre><code>from app.apis import BookAPI, SingleBookAPI\n\n\nurls = {\n    'book/': BookAPI,\n    'book/&lt;book_id&gt;/': SingleBookAPI,\n}\n</code></pre> </li> </ol> <p>You should write the Path Variable in <code>&lt;</code> and <code>&gt;</code></p>"},{"location":"generic_crud/#api-update-a-book","title":"API - Update a Book","text":"<ol> <li> <p>Inherit from <code>UpdateAPI</code></p> <pre><code>from panther.generics import RetrieveAPI, UpdateAPI\nfrom panther.request import Request\nfrom app.models import Book\n\n\nclass SingleBookAPI(RetrieveAPI, UpdateAPI):\n    ...\n\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre> </li> <li> <p>Add <code>input_model</code> so the <code>UpdateAPI</code> knows how to validate the <code>request.data</code></p> <p>We use the same serializer as CreateAPI serializer we defined above</p> <pre><code>from panther.generics import RetrieveAPI, UpdateAPI\nfrom panther.request import Request\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\nclass SingleBookAPI(RetrieveAPI, UpdateAPI):\n    input_model = BookSerializer\n\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre> </li> </ol>"},{"location":"generic_crud/#api-delete-a-book","title":"API - Delete a Book","text":"<ol> <li> <p>Inherit from <code>DeleteAPI</code></p> <pre><code>from panther.generics import RetrieveAPI, UpdateAPI, DeleteAPI\nfrom panther.request import Request\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\nclass SingleBookAPI(RetrieveAPI, UpdateAPI, DeleteAPI):\n    input_model = BookSerializer\n\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre> </li> <li> <p>It requires <code>object</code> method which we defined before, so it's done.</p> </li> </ol>"},{"location":"log_queries/","title":"Log Queries","text":"<p>Variable: <code>LOG_QUERIES</code> </p> <p>Type: <code>bool</code> </p> <p>Default: <code>False</code></p> <p>Panther log <code>perf_time</code> of every query if this variable is <code>True</code></p> <p>Make sure it is <code>False</code> on production for better performance</p>"},{"location":"log_queries/#log-example","title":"Log Example:","text":"<pre><code>INFO:     | 2023-03-19 20:37:27 | Query --&gt;  User.insert_one() --&gt; 1.6 ms\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Variable: <code>MIDDLEWARES</code> </p> <p>Type: <code>list</code> </p> <p>Default: <code>[]</code></p>"},{"location":"middlewares/#structure-of-middlewares","title":"Structure of middlewares","text":"<p><code>MIDDLEWARES</code> itself is a <code>list</code> of <code>tuples</code> which each <code>tuple</code> is like below:</p> <p>(<code>Dotted Address of The Middleware Class</code>, <code>kwargs as dict</code>)</p>"},{"location":"middlewares/#custom-middleware","title":"Custom Middleware","text":""},{"location":"middlewares/#middleware-types","title":"Middleware Types","text":"<p>We have 3 type of Middlewares, make sure that you are inheriting from the correct one:</p> <ul> <li> <p><code>Base Middleware</code>: which is used for both <code>websocket</code> and <code>http</code> requests </p> </li> <li> <p><code>HTTP Middleware</code>: which is only used for <code>http</code> requests</p> </li> <li> <p><code>Websocket Middleware</code>: which is only used for <code>websocket</code> requests</p> </li> </ul>"},{"location":"middlewares/#write-custom-middleware","title":"Write Custom Middleware","text":"<ul> <li> <p>Write a <code>class</code> and inherit from one of the classes below     <pre><code># For HTTP Requests\nfrom panther.middlewares.base import HTTPMiddleware\n\n# For Websocket Requests\nfrom panther.middlewares.base import WebsocketMiddleware\n\n# For Both HTTP and Websocket Requests\nfrom panther.middlewares.base import BaseMiddleware\n</code></pre></p> </li> <li> <p>Then you can write your custom <code>before()</code> and <code>after()</code> methods</p> </li> <li> <p>The <code>methods</code> should be <code>async</code></p> </li> <li><code>before()</code> should have <code>request</code> parameter</li> <li><code>after()</code> should have <code>response</code> parameter</li> <li>overwriting the <code>before()</code> and <code>after()</code> are optional</li> <li>The <code>methods</code> can get <code>kwargs</code> from their <code>__init__</code></li> </ul>"},{"location":"middlewares/#custom-http-middleware-example","title":"Custom HTTP Middleware Example","text":"<ul> <li> <p>core/middlewares.py <pre><code>from panther.middlewares.base import HTTPMiddleware\nfrom panther.request import Request\nfrom panther.response import Response\n\n\nclass CustomMiddleware(HTTPMiddleware):\n\n    def __init__(self, something):\n        self.something = something\n\n    async def before(self, request: Request) -&gt; Request:\n        print('Before Endpoint', self.something)\n        return request\n\n    async def after(self, response: Response) -&gt; Response:\n        print('After Endpoint', self.something)\n        return response\n</code></pre></p> </li> <li> <p>core/configs.py <pre><code>MIDDLEWARES = [\n      ('core.middlewares.CustomMiddleware', {'something': 'hello-world'}),\n]\n</code></pre></p> </li> </ul>"},{"location":"middlewares/#custom-http-websocket-middleware-example","title":"Custom HTTP + Websocket Middleware Example","text":"<ul> <li> <p>core/middlewares.py <pre><code>from panther.middlewares.base import BaseMiddleware\nfrom panther.request import Request\nfrom panther.response import Response\nfrom panther.websocket import GenericWebsocket \n\n\nclass SayHiMiddleware(BaseMiddleware):\n\n    def __init__(self, name):\n        self.name = name\n\n    async def before(self, request: Request | GenericWebsocket) -&gt; Request | GenericWebsocket:\n        print('Hello ', self.name)\n        return request\n\n    async def after(self, response: Response | GenericWebsocket) -&gt; Response | GenericWebsocket:\n        print('Goodbye ', self.name)\n        return response\n</code></pre></p> </li> <li> <p>core/configs.py <pre><code>MIDDLEWARES = [\n      ('core.middlewares.SayHiMiddleware', {'name': 'Ali Rn'}),\n]\n</code></pre></p> </li> </ul>"},{"location":"monitoring/","title":"Monitoring","text":"<p>Variable: <code>MONITORING</code> </p> <p>Type: <code>bool</code> </p> <p>Default: <code>False</code></p> <p>Panther log <code>perf_time</code> of every request if this variable is <code>True</code></p> <p>Then you can watch them live with: <code>panther monitor</code></p> <p>Make sure it is <code>False</code> on production for better performance</p> <p>It's using <code>monitoring</code> logger</p>"},{"location":"monitoring/#reference","title":"Reference","text":"<ul> <li>panther.monitoring.Monitoring</li> </ul>"},{"location":"monitoring/#log-example","title":"Log Example","text":"<pre><code>date time | method | path | ip:port | response_time(seconds) | status\n\n2023-12-11 18:23:42 | GET | /login | 127.0.0.1:55710 | 0.001117052001063712 | 200\n</code></pre>"},{"location":"monitoring/#monitoring-example","title":"Monitoring Example","text":""},{"location":"panther_odm/","title":"Panther ODM","text":""},{"location":"panther_odm/#find_one","title":"find_one","text":"<p>Get a single document from the database.</p> <pre><code>from app.models import User\n\nuser: User = await User.find_one(id=1, name='Ali')\nor\nuser: User = await User.find_one({'id': 1, 'name': 'Ali'})\nor\nuser: User = await User.find_one({'id': 1}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#find","title":"find","text":"<p>Get documents from the database.</p> <pre><code>users: Cursor = await User.find(age=18, name='Ali')\nor\nusers: Cursor = await User.find({'age': 18, 'name': 'Ali'})\nor\nusers: Cursor = await User.find({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#skip-limit-and-sort","title":"skip, limit and sort","text":"<p><code>skip()</code>, <code>limit()</code> and <code>sort()</code> are also available as chain methods</p> <pre><code>users: Cursor = await User.find(age=18, name='Ali').skip(10).limit(10).sort([('age', -1), ('name', 1)])\n</code></pre>"},{"location":"panther_odm/#cursor","title":"cursor","text":"<p>The <code>find()</code> method, returns a <code>Crusor</code> depends on the database - <code>from panther.db.cursor import Cursor</code> for <code>MongoDB</code> - <code>from pantherdb import Cursor</code> for <code>PantherDB</code></p> <p>You can work with these cursors as list and directly pass them to <code>Response(data=cursor)</code></p> <p>They are designed to return an instance of your model in <code>iterations</code>(<code>__next__()</code>) or accessing by index(<code>__getitem__()</code>)</p>"},{"location":"panther_odm/#all","title":"all","text":"<p>Get all documents from the database. (Alias of <code>.find()</code>)</p> <pre><code>users: Cursor = User.all()\n</code></pre>"},{"location":"panther_odm/#first","title":"first","text":"<p>Get the first document from the database.</p> <pre><code>from app.models import User\n\nuser: User = await User.first(age=18, name='Ali')\nor\nuser: User = await User.first({'age': 18, 'name': 'Ali'})\nor\nuser: User = await User.first({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#last","title":"last","text":"<p>Get the last document from the database.</p> <pre><code>from app.models import User\n\nuser: User = await User.last(age=18, name='Ali')\nor\nuser: User = await User.last({'age': 18, 'name': 'Ali'})\nor\nuser: User = await User.last({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#aggregate","title":"aggregate","text":"<p>Perform an aggregation using the aggregation framework on this collection.</p> <p>Only available in mongodb</p> <pre><code>from typing import Iterable\nfrom app.models import User\n\npipeline = [\n    {'$match': {...}},\n    {'$unwind': ...},\n    {'$group': {...}},\n    {'$project': {...}},\n    {'$sort': {...}}\n    ...\n]\nusers: Iterable[dict] = await User.aggregate(pipeline)\n</code></pre>"},{"location":"panther_odm/#count","title":"count","text":"<p>Count the number of documents in this collection.</p> <pre><code>from app.models import User\n\nusers_count: int = await User.count(age=18, name='Ali')\nor\nusers_count: int = await User.count({'age': 18, 'name': 'Ali'})\nor\nusers_count: int = await User.count({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#insert_one","title":"insert_one","text":"<p>Insert a single document.</p> <pre><code>from app.models import User\n\nuser: User = await User.insert_one(age=18, name='Ali')\nor\nuser: User = await User.insert_one({'age': 18, 'name': 'Ali'})\nor\nuser: User = await User.insert_one({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#insert_many","title":"insert_many","text":"<p>Insert an iterable of documents.</p> <pre><code>from app.models import User\n\nusers = [\n    {'age': 18, 'name': 'Ali'},\n    {'age': 17, 'name': 'Saba'},\n    {'age': 16, 'name': 'Amin'}\n]\n\nusers: list[User] = await User.insert_many(users)\n</code></pre>"},{"location":"panther_odm/#delete","title":"delete","text":"<p>Delete the document.</p> <pre><code>from app.models import User\n\nuser = await User.find_one(name='Ali')\n\nawait user.delete()\n</code></pre>"},{"location":"panther_odm/#delete_one","title":"delete_one","text":"<p>Delete a single document matching the filter.</p> <pre><code>from app.models import User\n\nis_deleted: bool = await User.delete_one(age=18, name='Ali')\nor\nis_deleted: bool = await User.delete_one({'age': 18, 'name': 'Ali'})\nor\nis_deleted: bool = await User.delete_one({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#delete_many","title":"delete_many","text":"<p>Delete one or more documents matching the filter.</p> <pre><code>from app.models import User\n\ndeleted_count: int = await User.delete_many(age=18, name='Ali')\nor\ndeleted_count: int = await User.delete_many({'age': 18, 'name': 'Ali'})\nor\ndeleted_count: int = await User.delete_many({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#update","title":"update","text":"<p>Update the document.</p> <pre><code>from app.models import User\n\nuser = await User.find_one(age=18, name='Ali')\n\nawait user.update(name='Saba', age=19)\nor\nawait user.update({'name': 'Saba'}, age=19)\nor\nawait user.update({'name': 'Saba', 'age': 19})\n</code></pre>"},{"location":"panther_odm/#update_one","title":"update_one","text":"<p>Update a single document matching the filter.</p> <ul> <li>You have to filter with a <code>dictionary</code> as <code>first parameter</code></li> <li>Then pass your new parameters</li> </ul> <pre><code>from app.models import User\n\nquery = {'id': 1}\n\nis_updated: bool = await User.update_one(query, age=18, name='Ali')\nor\nis_updated: bool = await User.update_one(query, {'age': 18, 'name': 'Ali'})\nor\nis_updated: bool = await User.update_one(query, {'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#update_many","title":"update_many","text":"<p>Update one or more documents that match the filter.</p> <ul> <li>You have to filter with a <code>dictionary</code> as <code>first parameter</code></li> <li>Then pass your new parameters</li> </ul> <pre><code>from app.models import User\n\nquery = {'name': 'Saba'}\n\nupdated_count: int = await User.update_many(query, age=18, name='Ali')\nor\nupdated_count: int = await User.update_many(query, {'age': 18, 'name': 'Ali'})\nor\nupdated_count: int = await User.update_many(query, {'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#find_one_or_insert","title":"find_one_or_insert","text":"<ul> <li>Get a single document from the database </li> <li>or </li> <li>Insert a single document</li> </ul> <pre><code>from app.models import User\n\nis_inserted, user = await User.find_one_or_insert(age=18, name='Ali')\nor\nis_inserted, user = await User.find_one_or_insert({'age': 18, 'name': 'Ali'})\nor\nis_inserted, user = await User.find_one_or_insert({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#find_one_or_raise","title":"find_one_or_raise","text":"<ul> <li>Get a single document from the database]</li> <li>or </li> <li>Raise an <code>NotFoundAPIError(f'{Model} Does Not Exist')</code></li> </ul> <pre><code>from app.models import User\n\nuser: User = await User.find_one_or_raise(age=18, name='Ali')\nor\nuser: User = await User.find_one_or_raise({'age': 18, 'name': 'Ali'})\nor\nuser: User = await User.find_one_or_raise({'age': 18}, name='Ali')\n</code></pre>"},{"location":"panther_odm/#save","title":"save","text":"<p>Save the document.</p> <ul> <li>If it has id --&gt; <code>Update</code> It</li> <li>else --&gt; <code>Insert</code> It</li> </ul> <pre><code>from app.models import User\n\n# Update\nuser = await User.find_one(name='Ali')\nuser.name = 'Saba'\nawait user.save()\n\n# Insert\nuser = User(name='Ali')\nawait user.save()\n</code></pre>"},{"location":"redis/","title":"Redis","text":"<p>Panther currently built-in supports 2 database (<code>MongoDB</code>, <code>PantherDB</code>), but you can define your own custom database connection and queries too.</p>"},{"location":"redis/#structure","title":"Structure","text":"<pre><code>REDIS = {\n    'class': 'address of the class',\n    'arg1': 'value1',\n    ...\n}\n</code></pre>"},{"location":"redis/#redisconnection","title":"RedisConnection","text":"<pre><code>REDIS = {\n    'class': 'panther.db.connections.RedisConnection',\n    'host': ...,  # default is localhost\n    'port': ...,  # default is 6379\n    'db': ...,  # default is 0\n    'websocket_db': ...,  # default is 0\n    ...\n}\n</code></pre>"},{"location":"redis/#notes","title":"Notes","text":"<ul> <li>The arguments are same as <code>redis.Redis.__init__()</code> except <code>websocket_db</code></li> <li>You can specify which <code>db</code> is for your <code>websocket</code> connections </li> </ul>"},{"location":"redis/#how-it-works","title":"How it works?","text":"<ul> <li> <p>Panther creates an async redis connection depends on <code>REDIS</code> block you defined in <code>configs</code></p> </li> <li> <p>You can access to it from <code>from panther.db.connections import redis</code></p> </li> <li> <p>Example:      <pre><code>from panther.db.connections import redis\n\nawait redis.set('name', 'Ali')\nresult = await redis.get('name')\nprint(result)  \n</code></pre></p> </li> </ul>"},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#432","title":"4.3.2","text":"<ul> <li>Support <code>Python 3.13</code> </li> </ul>"},{"location":"release_notes/#430","title":"4.3.0","text":"<ul> <li>Support <code>Jinja2 Template Engine</code> </li> </ul>"},{"location":"release_notes/#420","title":"4.2.0","text":"<ul> <li>Support <code>OPTIONS</code> method</li> </ul>"},{"location":"release_notes/#413","title":"4.1.3","text":"<ul> <li>Add <code>reload()</code> method to queries</li> <li>Add <code>get_input_model()</code> &amp; <code>get_output_model()</code> to <code>GenericAPI</code></li> <li>Support <code>per_delete()</code> &amp; <code>post_delete()</code> in <code>DeleteAPI</code> </li> <li>Support mongodb operators in <code>update(</code>) &amp; <code>update_one()</code></li> </ul>"},{"location":"release_notes/#412","title":"4.1.2","text":"<ul> <li>Fix some issues for <code>Windows</code></li> </ul>"},{"location":"release_notes/#411","title":"4.1.1","text":"<ul> <li>Fix an issue in <code>Response.prepare_data()</code> when <code>data</code> is <code>Cursor</code></li> <li>Split <code>paginate</code> and <code>template</code> in <code>Pagination</code></li> </ul>"},{"location":"release_notes/#410","title":"4.1.0","text":"<ul> <li>Support <code>prepare_response</code> in <code>Serializers</code></li> <li>Rename <code>objects()</code> to <code>cursor()</code></li> </ul>"},{"location":"release_notes/#401","title":"4.0.1","text":"<ul> <li>Fix an issue in <code>startup</code> lifespan</li> </ul>"},{"location":"release_notes/#400","title":"4.0.0","text":"<ul> <li>Move <code>database</code> and <code>redis</code> connections from <code>MIDDLEWARES</code> to their own block, <code>DATABASE</code> and <code>REDIS</code></li> <li>Make <code>Database</code> queries <code>async</code></li> <li>Make <code>Redis</code> queries <code>async</code></li> <li>Add <code>StreamingResponse</code></li> <li>Add <code>generics</code> API classes</li> <li>Add <code>login()</code> &amp; <code>logout()</code> to <code>JWTAuthentication</code> and used it in <code>BaseUser</code></li> <li>Support <code>Authentication</code> &amp; <code>Authorization</code> in <code>Websocket</code></li> <li>Rename all exceptions suffix from <code>Exception</code> to <code>Error</code> (https://peps.python.org/pep-0008/#exception-names)</li> <li>Support <code>pantherdb 2.0.0</code> (<code>Cursor</code> Added)</li> <li>Remove <code>watchfiles</code> from required dependencies</li> <li>Support <code>exclude</code> and <code>optional_fields</code> in <code>ModelSerializer</code></li> <li>Minor Improvements</li> </ul>"},{"location":"release_notes/#390","title":"3.9.0","text":"<ul> <li>Change the style of <code>ModelSerializer</code> usage </li> </ul>"},{"location":"release_notes/#382","title":"3.8.2","text":"<ul> <li>Add <code>content-type = application/json</code> header in raise response of <code>__call__</code> </li> </ul>"},{"location":"release_notes/#381","title":"3.8.1","text":"<ul> <li>Fix an issue in <code>_create_pantherdb_session()</code></li> </ul>"},{"location":"release_notes/#380","title":"3.8.0","text":"<ul> <li>Handle WebSocket connections when we have multiple workers with <code>multiprocessing.Manager</code></li> </ul>"},{"location":"release_notes/#370","title":"3.7.0","text":"<ul> <li>Add <code>ModelSerializer</code></li> </ul>"},{"location":"release_notes/#360","title":"3.6.0","text":"<ul> <li>Use <code>observable</code> pattern for loading database middleware and inheritance of the <code>Query</code> class</li> <li>Remove <code>IDType</code> from the <code>Model</code></li> <li>Change <code>encrypt_password()</code> method, now uses <code>scrypt</code> + <code>md5</code> </li> </ul>"},{"location":"release_notes/#351","title":"3.5.1","text":"<ul> <li>Set default behavior of <code>GenericWebsocket.connect</code> to ignore the connection (<code>reject</code>)</li> </ul>"},{"location":"release_notes/#350","title":"3.5.0","text":"<ul> <li>Add <code>WebsocketTestClient</code></li> </ul>"},{"location":"release_notes/#340","title":"3.4.0","text":"<ul> <li>Support <code>WebsocketMiddleware</code></li> </ul>"},{"location":"release_notes/#332","title":"3.3.2","text":"<ul> <li>Add <code>content-length</code> to response header</li> </ul>"},{"location":"release_notes/#331","title":"3.3.1","text":"<ul> <li>Check <code>ruff</code> installation on startup</li> <li>Fix an issue in <code>routing</code></li> </ul>"},{"location":"release_notes/#330","title":"3.3.0","text":"<ul> <li>Add Auto Reformat Code</li> </ul>"},{"location":"release_notes/#324","title":"3.2.4","text":"<ul> <li>Add all() query</li> <li>Add tests for <code>pantherdb</code>, <code>load_configs()</code>, <code>status.py</code>, <code>Panel</code>, <code>multipart</code>, <code>request headers</code></li> <li>Refactor <code>Headers()</code> class</li> <li>Check <code>uvloop</code> installation on <code>Panther init</code></li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#321","title":"3.2.1","text":"<ul> <li>Move <code>Startup</code> to <code>__call__</code></li> </ul>"},{"location":"release_notes/#320","title":"3.2.0","text":"<ul> <li>Support <code>Startup</code> &amp; <code>Shutdown</code> Events</li> </ul>"},{"location":"release_notes/#315","title":"3.1.5","text":"<ul> <li>Support <code>Websocket</code> in the <code>monitoring</code> </li> <li>Refactor <code>collect_all_models()</code></li> </ul>"},{"location":"release_notes/#314","title":"3.1.4","text":"<ul> <li>Check ws redis connection on the <code>init</code></li> <li>Refactor <code>Monitoring</code> class and usage</li> <li>Improve <code>logging</code> config</li> <li>Check database connection before query</li> </ul>"},{"location":"release_notes/#313","title":"3.1.3","text":"<ul> <li>Add <code>Image</code> base class </li> <li>Add <code>size</code> to <code>File</code> base class</li> <li>Improve the way of loading <code>configs</code> in <code>single-file</code> structure</li> <li>Improve <code>background_tasks.py</code>, <code>generate_ws_connection_id()</code></li> <li><code>bpython</code> removed from being the default python shell</li> <li>Improve <code>load_middlewares()</code> error handling </li> <li>Print <code>configs</code> on the <code>run</code></li> <li>Add <code>requirements.txt</code> for development </li> <li>Update <code>roadmap.jpg</code>, <code>README.md</code></li> </ul>"},{"location":"release_notes/#312","title":"3.1.2","text":"<ul> <li>Add new methods to <code>BackgroundTask</code></li> <li><code>every_seconds()</code></li> <li><code>every_minutes()</code></li> <li><code>every_hours()</code></li> <li><code>every_days()</code></li> <li><code>every_weeks()</code></li> <li><code>at()</code></li> </ul>"},{"location":"release_notes/#311","title":"3.1.1","text":"<ul> <li>Upgrade <code>PantherDB</code> version</li> <li>Add <code>first()</code>, <code>last()</code> queries</li> </ul>"},{"location":"release_notes/#310","title":"3.1.0","text":"<ul> <li>Add <code>BackgroundTasks</code></li> </ul>"},{"location":"release_notes/#303","title":"3.0.3","text":"<ul> <li>Add <code>find_one_or_raise</code> query</li> <li>Add <code>last_login</code> to <code>BaseUser</code></li> <li>Add <code>refresh_life_time</code> to <code>JWTConfig</code></li> <li>Add <code>encode_refresh_token()</code> to <code>JWTAuthentication</code></li> <li>Add <code>encrypt_password()</code></li> <li>Handle <code>PantherException</code></li> <li>Handle <code>RedisConnection</code> without <code>connection_pool</code></li> </ul>"},{"location":"release_notes/#302","title":"3.0.2","text":"<ul> <li>Added 'utf-8' encoding while opening the file \"README.md\" in setup.py</li> <li>Fixed panther shell not working issue in windows.</li> <li>Added a condition to raise error if no argument is passed to panther command in cli.</li> </ul>"},{"location":"release_notes/#301","title":"3.0.1","text":"<ul> <li>Assume content-type is 'application/json' if it was empty</li> <li>Fix an issue on creating instance of model when query is done</li> </ul>"},{"location":"release_notes/#300","title":"3.0.0","text":"<ul> <li>Support Websocket</li> <li>Implement Built-in TestClient</li> <li>Support Single-File Structure</li> <li>Support <code>bytes</code> as <code>Response.data</code></li> <li>Add <code>methods</code> to <code>API()</code></li> <li>Change <code>Request.pure_data</code> to <code>Request.data</code></li> <li>Change <code>Request.data</code> to <code>Request.validated_data</code></li> <li>Change <code>panther.middlewares.db.Middleware</code> to <code>panther.middlewares.db.DatabaseMiddleware</code></li> <li>Change <code>panther.middlewares.redis.Middleware</code> to <code>panther.middlewares.redis.RedisMiddleware</code></li> <li>Fix <code>panther run</code> command</li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#242","title":"2.4.2","text":"<ul> <li>Don't log content-type when it's not supported</li> </ul>"},{"location":"release_notes/#241","title":"2.4.1","text":"<ul> <li>Fix an issue in collect_all_models() in Windows</li> </ul>"},{"location":"release_notes/#240","title":"2.4.0","text":"<ul> <li>Handle Complex Multipart-FormData</li> </ul>"},{"location":"release_notes/#233","title":"2.3.3","text":"<ul> <li>Fix a bug in response headers</li> </ul>"},{"location":"release_notes/#232","title":"2.3.2","text":"<ul> <li>Fix a bug in Template</li> </ul>"},{"location":"release_notes/#231","title":"2.3.1","text":"<ul> <li>Handle PlainTextResponse</li> <li>Handle Custom Header in Response</li> <li>Change the way of accepting 'URLs' in configs (relative -&gt; dotted)</li> <li>Fix an issue in collect_all_models()</li> </ul>"},{"location":"release_notes/#230","title":"2.3.0","text":"<ul> <li>Handle HTMLResponse</li> </ul>"},{"location":"release_notes/#220","title":"2.2.0","text":"<ul> <li>Supporting File </li> </ul>"},{"location":"release_notes/#216","title":"2.1.6","text":"<ul> <li>Fix validation errors on nested inputs</li> </ul>"},{"location":"release_notes/#215","title":"2.1.5","text":"<ul> <li>Fix response of nested Models in _panel//"},{"location":"release_notes/#214","title":"2.1.4","text":"<ul> <li>Add access-control-allow-origin to response header</li> </ul>"},{"location":"release_notes/#213","title":"2.1.3","text":"<ul> <li>Upgrade greenlet version in requirements for python3.12</li> </ul>"},{"location":"release_notes/#212","title":"2.1.2","text":"<ul> <li>Add ruff.toml</li> <li>Add Coverage to workflows</li> <li>Fix a bug for running in Windows</li> </ul>"},{"location":"release_notes/#211","title":"2.1.1","text":"<ul> <li>Fix a bug in main.py imports</li> </ul>"},{"location":"release_notes/#210","title":"2.1.0","text":"<ul> <li>Support Sync APIs</li> </ul>"},{"location":"release_notes/#200","title":"2.0.0","text":"<ul> <li>Supporting class-base APIs</li> </ul>"},{"location":"release_notes/#1720","title":"1.7.20","text":"<ul> <li>Fix an issue in find_endpoint()</li> </ul>"},{"location":"release_notes/#1719","title":"1.7.19","text":"<ul> <li>Fix an issue in routing</li> <li>Fix an issue on return complex dict Response</li> </ul>"},{"location":"release_notes/#1718","title":"1.7.18","text":"<ul> <li>Remove uvloop from requirements for now (we had issue in windows)</li> </ul>"},{"location":"release_notes/#1716","title":"1.7.16","text":"<ul> <li>Trying to fix requirements for windows</li> <li>Minor improvement in BaseMongoDBQuery</li> </ul>"},{"location":"release_notes/#1715","title":"1.7.15","text":"<ul> <li>Fix an issue in handling form-data</li> </ul>"},{"location":"release_notes/#1714","title":"1.7.14","text":"<ul> <li>Add Cache and Throttling doc to FirstCrud</li> <li>Fix an issue in BasePantherDBQuery._merge() </li> </ul>"},{"location":"release_notes/#1713","title":"1.7.13","text":"<ul> <li>Hotfix validation of _id in Model()</li> </ul>"},{"location":"release_notes/#1712","title":"1.7.12","text":"<ul> <li>Fix a bug in routing</li> </ul>"},{"location":"release_notes/#1711","title":"1.7.11","text":"<ul> <li>Fix an issue in template</li> </ul>"},{"location":"release_notes/#1710","title":"1.7.10","text":"<ul> <li>Fix a bug in <code>collect_urls</code> and rename it to <code>flatten_urls</code></li> <li>Add General Tests</li> <li>Compatible with python3.10 (Not Tested)</li> <li>Working on docs</li> </ul>"},{"location":"release_notes/#179","title":"1.7.9","text":"<ul> <li>Working on doc</li> </ul>"},{"location":"release_notes/#178","title":"1.7.8","text":"<ul> <li>Fix a bug</li> <li>Update docs</li> </ul>"},{"location":"release_notes/#178_1","title":"1.7.8","text":"<ul> <li>Fix a bug</li> <li>Update docs</li> </ul>"},{"location":"release_notes/#177","title":"1.7.7","text":"<ul> <li>Fix a bug</li> </ul>"},{"location":"release_notes/#175","title":"1.7.5","text":"<ul> <li>Change the way of raising exception in JWTAuthentication</li> <li>Rename User model to BaseUser</li> <li>Fix template</li> </ul>"},{"location":"release_notes/#174","title":"1.7.4","text":"<ul> <li>Crop Logo</li> </ul>"},{"location":"release_notes/#173","title":"1.7.3","text":"<ul> <li>Add Throttling Doc</li> <li>Fix some issue in Doc</li> </ul>"},{"location":"release_notes/#172","title":"1.7.2","text":"<ul> <li>Add Throttling to example</li> <li>Customize install_requires in setup.py</li> <li>Improve monitoring cli command</li> </ul>"},{"location":"release_notes/#171","title":"1.7.1","text":"<ul> <li>Rename db BaseModel to Model </li> <li>Add more docs</li> </ul>"},{"location":"release_notes/#170","title":"1.7.0","text":"<ul> <li>Add Throttling</li> </ul>"},{"location":"release_notes/#161","title":"1.6.1","text":"<ul> <li>Add AdminPermission</li> </ul>"},{"location":"release_notes/#160","title":"1.6.0","text":"<ul> <li>Handle Permissions</li> </ul>"},{"location":"release_notes/#152","title":"1.5.2","text":"<ul> <li>Improve Response data serialization</li> <li>Fix a bug in JWTAuthentication</li> </ul>"},{"location":"release_notes/#151","title":"1.5.1","text":"<ul> <li>Fix error messages</li> </ul>"},{"location":"release_notes/#150","title":"1.5.0","text":"<ul> <li>Refactor Mongodb ODM</li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#140","title":"1.4.0","text":"<ul> <li>Add QUERY_LOG</li> </ul>"},{"location":"release_notes/#132","title":"1.3.2","text":"<ul> <li>Add Uvicorn to the setup requirements</li> <li>Update Readme</li> </ul>"},{"location":"release_notes/#131","title":"1.3.1","text":"<ul> <li>Fix a bug in project creation template</li> <li>Fix a bug in caching</li> </ul>"},{"location":"release_notes/#130","title":"1.3.0","text":"<ul> <li>Add PantherDB to Panther</li> <li>Remove tinydb</li> </ul>"},{"location":"release_notes/#127","title":"1.2.7","text":"<ul> <li>Fix a bug while using tinydb</li> </ul>"},{"location":"release_notes/#126","title":"1.2.6","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#125","title":"1.2.5","text":"<ul> <li>Fix install_requires issue</li> <li>Add benchmarks to docs</li> </ul>"},{"location":"release_notes/#124","title":"1.2.4","text":"<ul> <li>Remove Uvicorn From install_requires</li> <li>Working on Docs</li> </ul>"},{"location":"release_notes/#123","title":"1.2.3","text":"<ul> <li>Fix URL Routing</li> </ul>"},{"location":"release_notes/#121","title":"1.2.1","text":"<ul> <li>Path Variable Handled Successfully</li> </ul>"},{"location":"release_notes/#120","title":"1.2.0","text":"<ul> <li>Read multipart/form-data with Regex</li> </ul>"},{"location":"release_notes/#119","title":"1.1.9","text":"<ul> <li>Refactoring code style with ruff </li> <li>Add asyncio.TaskGroup() </li> </ul>"},{"location":"release_notes/#118","title":"1.1.8","text":"<ul> <li>Refactor cli run command </li> </ul>"},{"location":"release_notes/#117","title":"1.1.7","text":"<ul> <li>Add benchmark pictures to doc </li> </ul>"},{"location":"release_notes/#115","title":"1.1.5","text":"<ul> <li>Clean Readme</li> <li>Clean main.py </li> </ul>"},{"location":"release_notes/#114","title":"1.1.4","text":"<ul> <li>Update Readme </li> </ul>"},{"location":"release_notes/#113","title":"1.1.3","text":"<ul> <li>Fix a query in TinyDB </li> </ul>"},{"location":"release_notes/#112","title":"1.1.2","text":"<ul> <li>Add delete_many query to TinyDB </li> </ul>"},{"location":"release_notes/#111","title":"1.1.1","text":"<ul> <li>Add TinyDB</li> </ul>"},{"location":"release_notes/#110","title":"1.1.0","text":"<ul> <li>Debug the Template </li> </ul>"},{"location":"release_notes/#109","title":"1.0.9","text":"<ul> <li>Handle string exceptions (raise them as detail: error) </li> <li>Little debug on MongoQueries</li> </ul>"},{"location":"release_notes/#107","title":"1.0.7","text":"<ul> <li>Working on queries</li> <li>Fix a bug in query methods </li> </ul>"},{"location":"release_notes/#106","title":"1.0.6","text":"<ul> <li>Update the Template </li> </ul>"},{"location":"release_notes/#104","title":"1.0.4","text":"<ul> <li>Debug template </li> </ul>"},{"location":"release_notes/#102","title":"1.0.2","text":"<ul> <li>Add global config</li> <li>Split the BaseModels</li> <li>Worked on MongoQuery</li> <li>Set Mongo as default database while creating project </li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#101","title":"1.0.1","text":"<ul> <li>Add alembic To Project </li> </ul>"},{"location":"release_notes/#10","title":"1.0.","text":"<ul> <li>Refactor &amp; Complete the CLI </li> </ul>"},{"location":"release_notes/#019","title":"0.1.9","text":"<ul> <li>Fix install_requires</li> </ul>"},{"location":"release_notes/#018","title":"0.1.8","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#017","title":"0.1.7","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#016","title":"0.1.6","text":"<ul> <li>Handle Most Types as Data in Response</li> </ul>"},{"location":"release_notes/#014","title":"0.1.4","text":"<ul> <li>Working On DB Connection </li> </ul>"},{"location":"release_notes/#001","title":"0.0.1","text":"<ul> <li>Make It Ready For PyPI </li> </ul>"},{"location":"serializer/","title":"Serializer","text":"<p>You can write your <code>serializer</code> in \u06f3 style:</p>"},{"location":"serializer/#style-1-pydantic","title":"Style 1 (Pydantic)","text":"<p>Write a normal <code>pydantic</code> class and use it as serializer:</p> <pre><code> from pydantic import BaseModel\n from pydantic import Field\n\n from panther.app import API\n from panther.request import Request\n from panther.response import Response\n\n\n class UserSerializer(BaseModel):\n     username: str\n     password: str\n     first_name: str = Field(default='', min_length=2)\n     last_name: str = Field(default='', min_length=4)\n\n\n @API(input_model=UserSerializer)\n async def serializer_example(request: Request):\n     return Response(data=request.validated_data)\n</code></pre>"},{"location":"serializer/#style-2-model-serializer","title":"Style 2 (Model Serializer)","text":"<p>Use panther <code>ModelSerializer</code> to write your serializer which will use your <code>model</code> to create fields.</p> <pre><code> from pydantic import Field\n\n from panther import status\n from panther.app import API\n from panther.db import Model\n from panther.request import Request\n from panther.response import Response\n from panther.serializer import ModelSerializer\n\n\n class User(Model):\n     username: str\n     password: str\n     first_name: str = Field(default='', min_length=2)\n     last_name: str = Field(default='', min_length=4)\n\n # type 1 - using fields\n class UserModelSerializer(ModelSerializer):\n     class Config:\n         model = User\n         fields = ['username', 'first_name', 'last_name']\n         required_fields = ['first_name']\n\n # type 2 - using exclude\n class UserModelSerializer(ModelSerializer):\n     class Config:\n         model = User\n         fields = '*'\n         required_fields = ['first_name']\n         exclude = ['id', 'password']\n\n\n @API(input_model=UserModelSerializer)\n async def model_serializer_example(request: Request):\n     return Response(data=request.validated_data, status_code=status.HTTP_202_ACCEPTED)\n</code></pre>"},{"location":"serializer/#notes","title":"Notes","text":"<ol> <li>In the example above, <code>ModelSerializer</code> will look up for the value of <code>Config.fields</code> in the <code>User.model_fields</code> and use their <code>type</code> and <code>value</code> for the <code>validation</code>.</li> <li><code>Config.model</code> and <code>Config.fields</code> are <code>required</code> when you are using <code>ModelSerializer</code>.</li> <li>You can force a field to be required with <code>Config.required_fields</code> </li> <li>You can force a field to be optional with <code>Config.optional_fields</code> </li> <li><code>Config.required_fields</code> and <code>Config.optional_fields</code> can't include same fields </li> <li>If you want to use <code>Config.required_fields</code> or <code>Config.optional_fields</code> you have to put their value in <code>Config.fields</code> too.</li> <li><code>Config.fields</code> &amp; <code>Config.required_fields</code> &amp; <code>Config.optional_fields</code> can be <code>*</code> too (Include all the model fields)</li> <li><code>Config.exclude</code> is mostly used when <code>Config.fields</code> is <code>'*'</code></li> </ol>"},{"location":"serializer/#style-3-model-serializer-pydantic","title":"Style 3 (Model Serializer + Pydantic)","text":"<p>You can use <code>pydantic.BaseModel</code> features in <code>ModelSerializer</code> too.</p> <pre><code> from pydantic import Field, field_validator, ConfigDict\n\n from panther import status\n from panther.app import API\n from panther.db import Model\n from panther.request import Request\n from panther.response import Response\n from panther.serializer import ModelSerializer\n\n\n class User(Model):\n     username: str\n     password: str\n     first_name: str = Field(default='', min_length=2)\n     last_name: str = Field(default='', min_length=4)\n\n class UserModelSerializer(ModelSerializer):\n     model_config = ConfigDict(str_to_upper=True)\n     age: int = Field(default=20)\n     is_male: bool\n     username: str\n\n     class Config:\n         model = User\n         fields = ['first_name', 'last_name']\n         required_fields = ['first_name']\n         optional_fields = ['last_name']\n\n @field_validator('username')\n def validate_username(cls, username):\n     print(f'{username=}')\n     return username\n\n\n @API(input_model=UserModelSerializer)\n async def model_serializer_example(request: Request):\n     return Response(data=request.validated_data, status_code=status.HTTP_202_ACCEPTED)\n</code></pre>"},{"location":"serializer/#notes_1","title":"Notes","text":"<ol> <li>You can add custom <code>fields</code> </li> <li>You can add <code>model_config</code> as <code>attribute</code> or as <code>Config</code></li> <li>You can use <code>@field_validator</code> and other <code>validators</code> of <code>pydantic</code>.</li> </ol>"},{"location":"single_file/","title":"Single-File","text":"<p>If you want to work with <code>Panther</code> in a <code>single-file</code> structure, follow the steps below.</p>"},{"location":"single_file/#steps","title":"Steps","text":"<ol> <li> <p>Write your <code>APIs</code> as you like</p> <pre><code>from panther.app import API\n\n@API()\nasync def hello_world_api():\n    return {'detail': 'Hello World'}\n</code></pre> </li> <li> <p>Add your <code>APIs</code> to a <code>dict</code> (example: <code>url_routing</code>)</p> <p><pre><code>from panther.app import API\n\n@API()\nasync def hello_world_api():\n    return {'detail': 'Hello World'}\n\nurl_routing = {\n    '/': hello_world_api,\n}\n</code></pre> 3. Create an <code>app</code> and pass your current <code>module name</code> and <code>urls</code> to it.</p> <p><pre><code>from panther import Panther\nfrom panther.app import API\n\n@API()\nasync def hello_world_api():\n    return {'detail': 'Hello World'}\n\nurl_routing = {\n    '/': hello_world_api,\n}\n\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre> 4. Run the project</p> <ul> <li>If name of your file is <code>main.py</code> --&gt;  <code>panther run</code></li> <li>else use <code>uvicorn</code> --&gt;    <code>uvicorn file_name:app</code></li> </ul> </li> </ol>"},{"location":"single_file/#notes","title":"Notes","text":"<ul> <li><code>URLs</code> is a required config unless you pass the <code>urls</code> directly to the <code>Panther</code> </li> <li>When you pass the <code>configs</code> to the <code>Panther(configs=...)</code>, Panther is going to load the configs from this file,  else it is going to load <code>core/configs.py</code> file</li> </ul> <pre><code>from panther import Panther\nfrom panther.app import API\n\n@API()\nasync def hello_world_api():\n     return {'detail': 'Hello World'}\n\nurl_routing = {\n     '/': hello_world_api,\n}\n\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre>"},{"location":"throttling/","title":"Throttling","text":"<p>Variable: <code>THROTTLING</code> </p> <p>Type: <code>str</code> </p> <p>For <code>Throttling</code> you can set a default value in <code>configs</code> or set custom value per <code>API()</code></p> <p>The default value is going to use for all the APIs unless it has custom value</p> <p>The <code>Throttling</code> class has 2 fields, <code>rate</code> &amp; <code>duration</code></p> <p>rate: int</p> <p>duration: datetime.timedelta</p> <p>It will return <code>Too Many Request (status_code: 429)</code>, if user trying to send requests more than <code>rate</code> in the <code>duration</code>, and user will be banned( gets <code>Too Many Request</code> ) for <code>duration</code>.</p>"},{"location":"throttling/#set-throttling-for-all-apis","title":"Set Throttling For All APIs:","text":"<p>in <code>configs</code> <pre><code>from datetime import timedelta\n\nfrom panther.throttling import Throttling\n\n\n# User only can request 5 times in every minute\nTHROTTLING = Throttling(rate=5, duration=timedelta(minutes=1))\n</code></pre></p>"},{"location":"throttling/#set-throttling-for-single-api","title":"Set Throttling For Single API:","text":"<p>in <code>apis.py</code> <pre><code>from datetime import timedelta\n\nfrom panther.throttling import Throttling\nfrom panther.app import API, GenericAPI\n\n\n# User only can request 5 times in every minute\nInfoThrottling = Throttling(rate=5, duration=timedelta(minutes=1))\n\n\n@API(throttling=InfoThrottling)\nasync def info_api():\n    pass\n\nclass InfoAPI(GenericAPI):\n    throttling = InfoThrottling\n    pass\n</code></pre></p>"},{"location":"todo/","title":"Todo","text":"<ul> <li>[ ] Improve HTTP <code>Option</code> Method</li> <li>[ ] Support Other HTTP Methods</li> <li>[ ] Support Cookies</li> <li>[ ] Add Middleware For CORS</li> <li>[ ] Add Multi-Language Feature to Docs</li> <li>[ ] Implement Generic <code>CreateAPI</code> Class</li> </ul>"},{"location":"urls/","title":"URLs","text":"<p>Variable: <code>URLs</code> </p> <p>Type: <code>str</code> </p> <p>Required: <code>True</code></p> <ul> <li><code>URLs</code> should point to your root <code>urls</code> with dotted address (<code>path.module.url_dict</code>)</li> <li>The target of <code>URLs</code> should be <code>dict</code>.</li> <li> <p>The <code>key</code> in <code>url_routing</code> is the <code>path</code> &amp; value is the <code>endpoint</code> or another <code>dict</code></p> </li> <li> </li> </ul>"},{"location":"urls/#path-variables-are-handled-like-below","title":"Path Variables are handled like below:","text":"<ul> <li>&lt;<code>variable_name</code>&gt;</li> <li>Example: <code>user/&lt;user_id&gt;/blog/&lt;title&gt;/</code></li> <li>The <code>endpoint</code> should have parameters with those names too</li> <li>Example Function-Base: <code>async def profile_api(user_id: int, title: str):</code></li> <li>Example Class-Base: <code>async def get(self, user_id: int, title: str):</code></li> </ul>"},{"location":"urls/#example","title":"Example","text":"<ul> <li><code>configs</code> <pre><code>URLs = 'core.urls.url_routing\n</code></pre></li> <li>core/urls.py     <pre><code>from app.urls import app_urls\n\nurl_routing = {\n    'user/': app_urls,\n}\n</code></pre></li> <li> <p>app/urls.py     <pre><code>from app.apis import *\n\nurls = {\n    'login/': login_api,\n    'logout/': logout_api,\n    'profile/&lt;user_id&gt;/': profile_api,\n}\n</code></pre></p> </li> <li> <p>app/apis.py     <pre><code>...\n\n@API()\nasync def profile_api(user_id: int):\n    return User.find_one(id=user_id)\n</code></pre></p> </li> </ul>"},{"location":"websocket/","title":"WebSocket","text":"<p>Panther supports <code>WebSockets</code> routing just like <code>APIs</code></p>"},{"location":"websocket/#structure-requirements","title":"Structure &amp; Requirements","text":""},{"location":"websocket/#create-websocket-class","title":"Create WebSocket Class","text":"<p>Create the <code>BookWebsocket()</code> in <code>app/websockets.py</code> which inherited from <code>GenericWebsocket</code>: </p> <pre><code>from panther.websocket import GenericWebsocket\n\n\nclass BookWebsocket(GenericWebsocket):\n    async def connect(self):\n        await self.accept()\n        print(f'{self.connection_id=}')\n\n    async def receive(self, data: str | bytes):\n        # Just Echo The Message\n        await self.send(data=data)\n</code></pre> <p>We are going to discuss it below ...</p>"},{"location":"websocket/#update-urls","title":"Update URLs","text":"<p>Add the <code>BookWebsocket</code> in <code>app/urls.py</code>:</p> <pre><code>from app.websockets import BookWebsocket\n\n\nurls = {\n    'ws/book/': BookWebsocket,\n}\n</code></pre>"},{"location":"websocket/#how-it-works","title":"How It Works?","text":"<ol> <li>Client tries to connect to your <code>ws/book/</code> url with <code>websocket</code> protocol</li> <li>The <code>connect()</code> method of your <code>BookWebsocket</code> is going to call</li> <li>You should validate the connection with <code>self.headers</code>, <code>self.query_params</code> or etc</li> <li>Then <code>accept()</code> the connection with <code>self.accept()</code> otherwise it is going to be <code>rejected</code> by default.</li> <li>Now you can see the unique <code>connection_id</code> which is specified to this user with <code>self.connection_id</code>, you may want to store it somewhere (<code>db</code>, <code>cache</code>, or etc.)</li> <li>If the client sends you any message, you will receive it in <code>receive()</code> method, the client message can be <code>str</code> or <code>bytes</code>.</li> <li>If you want to send anything to the client:<ul> <li>In websocket class scope: You can send it with <code>self.send()</code> which only takes <code>data</code>.</li> <li>Out of websocket class scope: You can send it with <code>send_message_to_websocket()</code> from <code>panther.websocket</code>, it's an <code>async</code> function which takes 2 args, <code>connection_id</code> and <code>data</code>(which can have any type):     <pre><code>from panther.websocket import send_message_to_websocket\nawait send_message_to_websocket(connection_id='7e82d57c9ec0478787b01916910a9f45', data='New Message From WS') \n</code></pre></li> </ul> </li> <li>If you want to use <code>webscoket</code> in a backend with <code>multiple workers</code>, we recommend you to add <code>RedisMiddleware</code> in your <code>configs</code> [Adding Redis Middleware]</li> <li> <p>If you don't want to add <code>RedisMiddleware</code> and you still want to run <code>websocket</code> with <code>multiple workers</code> with <code>gunicorn</code>,  you have to use <code>--preload</code>, like below:    <pre><code>gunicorn -w 10 -k uvicorn.workers.UvicornWorker main:app --preload\n</code></pre></p> </li> <li> <p>If you want to close a connection:</p> <ul> <li>In websocket class scope: You can close connection with <code>self.close()</code> method which takes 2 args, <code>code</code> and <code>reason</code>:     <pre><code>from panther import status\nawait self.close(code=status.WS_1000_NORMAL_CLOSURE, reason='I just want to close it')\n</code></pre></li> <li>Out of websocket class scope: You can close it with <code>close_websocket_connection()</code> from <code>panther.websocket</code>, it's <code>async</code> function with takes 3 args, <code>connection_id</code>, <code>code</code> and <code>reason</code>, like below:      <pre><code>from panther import status\nfrom panther.websocket import close_websocket_connection\nawait close_websocket_connection(connection_id='7e82d57c9ec0478787b01916910a9f45', code=status.WS_1008_POLICY_VIOLATION, reason='')\n</code></pre></li> </ul> </li> <li> <p><code>Path Variables</code> will be passed to <code>connect()</code>:    <pre><code> from panther.websocket import GenericWebsocket\n\n class UserWebsocket(GenericWebsocket):\n     async def connect(self, user_id: int, room_id: str):\n         await self.accept()\n\n url = {\n     '/ws/&lt;user_id&gt;/&lt;room_id&gt;/': UserWebsocket   \n }\n</code></pre></p> </li> <li>Enjoy.</li> </ol>"}]}