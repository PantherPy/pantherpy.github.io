{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#panther","title":"Panther","text":"<p>A Fast &amp; Friendly Web Framework for Building Async APIs with Python 3.10+</p> <p> </p> <p> </p>"},{"location":"#why-choose-panther","title":"\ud83d\udc3e Why Choose Panther?","text":"<p>Panther is designed to be fast, simple, and powerful. Here's what makes it special:</p> <ul> <li>One of the fastest Python frameworks available</li> <li>File-based database (PantherDB) - No external database setup required</li> <li>Document-oriented ODM - Supports MongoDB &amp; PantherDB with familiar syntax</li> <li>API caching system - In-memory and Redis support</li> <li>OpenAPI/Swagger - Auto-generated API documentation</li> <li>WebSocket support - Real-time communication out of the box</li> <li>Authentication &amp; Permissions - Built-in security features</li> <li>Background tasks - Handle long-running operations</li> <li>Middleware &amp; Throttling - Extensible and configurable</li> </ul>"},{"location":"#benchmark","title":"Benchmark","text":"<p>[TechEmpower Benchmark]</p>"},{"location":"#supported-by","title":"Supported by","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install panther\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li> <p>Create a new project directory <pre><code>$ mkdir my_panther_app\n$ cd my_panther_app\n</code></pre></p> </li> <li> <p>Set up your environment <pre><code>$ python3 -m venv .venv\n$ source .venv/bin/activate  # On Windows: .\\.venv\\Scripts\\activate\n$ pip install panther\n</code></pre></p> </li> <li> <p>Create your first application</p> <p>Create a <code>main.py</code> file with one of the examples below.</p> </li> </ol>"},{"location":"#basic-api-example","title":"Basic API Example","text":"<p>Here's a simple REST API endpoint that returns a \"Hello World\" message:</p> main.py<pre><code>from datetime import datetime, timedelta\nfrom panther import status, Panther\nfrom panther.app import GenericAPI\nfrom panther.openapi.urls import url_routing as openapi_url_routing\nfrom panther.response import Response\n\nclass HelloAPI(GenericAPI):\n    # Cache responses for 10 seconds\n    cache = timedelta(seconds=10)\n\n    def get(self):\n        current_time = datetime.now().isoformat()\n        return Response(\n            data={'message': f'Hello from Panther! \ud83d\udc3e | {current_time}'},\n            status_code=status.HTTP_200_OK\n        )\n\n# URL routing configuration\nurl_routing = {\n    '/': HelloAPI,\n    'swagger/': openapi_url_routing,  # Auto-generated API docs\n}\n\n# Create your Panther app\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre>"},{"location":"#websocket-example","title":"WebSocket Example","text":"<p>Here's a simple WebSocket echo server that sends back any message it receives:</p> main.py<pre><code>from panther import Panther\nfrom panther.app import GenericAPI\nfrom panther.response import HTMLResponse\nfrom panther.websocket import GenericWebsocket\n\nclass EchoWebsocket(GenericWebsocket):\n    async def connect(self, **kwargs):\n        await self.accept()\n        await self.send(\"Connected to Panther WebSocket!\")\n\n    async def receive(self, data: str | bytes):\n        # Echo back the received message\n        await self.send(f\"Echo: {data}\")\n\nclass WebSocketPage(GenericAPI):\n    def get(self):\n        template = \"\"\"\n        &lt;h2&gt;\ud83d\udc3e Panther WebSocket Echo Server&lt;/h2&gt;\n        &lt;input id=\"msg\"&gt;&lt;button onclick=\"s.send(msg.value)\"&gt;Send&lt;/button&gt;\n        &lt;ul id=\"log\"&gt;&lt;/ul&gt;\n        &lt;script&gt;\n            const s = new WebSocket('ws://127.0.0.1:8000/ws');\n            s.onmessage = e =&gt; log.innerHTML += `&lt;li&gt;&lt;- ${msg.value}&lt;/li&gt;&lt;li&gt;-&gt; ${e.data}&lt;/li&gt;`;\n        &lt;/script&gt;\n        \"\"\"\n        return HTMLResponse(template)\n\nurl_routing = {\n    '': WebSocketPage,\n    'ws': EchoWebsocket,\n}\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre>"},{"location":"#running-your-application","title":"Running Your Application","text":"<ol> <li> <p>Start the development server <pre><code>$ panther run main:app --reload\n</code></pre></p> <p>Note: Panther uses Uvicorn as the default ASGI server, but you can also use Granian, Daphne, or any ASGI-compatible server.</p> </li> <li> <p>Test your application</p> <ul> <li>For the API example: Visit http://127.0.0.1:8000/ to see the \"Hello World\" response</li> <li>For the WebSocket example: Visit http://127.0.0.1:8000/ and send a message. </li> </ul> </li> </ol>"},{"location":"admin_panel/","title":"Admin Panel","text":"<p>\u26a0\ufe0f WARNING: The Panther Admin Panel is currently in development. Do NOT use it in production environments!</p> <p>Contributions, feedback, and ideas are welcome!</p>"},{"location":"admin_panel/#panther-admin-panel","title":"Panther Admin Panel","text":"<p>Panther provides a built-in admin panel that allows you to easily manage your database models through a web interface.</p>"},{"location":"admin_panel/#enabling-the-admin-panel","title":"Enabling the Admin Panel","text":"<p>To enable the admin panel in your project, follow these steps:</p>"},{"location":"admin_panel/#1-add-the-admin-panel-urls","title":"1. Add the Admin Panel URLs","text":"<p>First, ensure your main URL configuration includes the admin panel routes. e.g. open your <code>core/urls.py</code> and add the following:</p> core/urls.py<pre><code>from panther.panel.urls import url_routing as panel_url_routing\n\nurl_routing = {\n    'panel/': panel_url_routing,\n    # ... other routes ...\n}\n</code></pre> <p>Note: If you are using a different file for your URL routing, adjust the import and assignment accordingly.</p>"},{"location":"admin_panel/#2-update-your-configs-if-needed","title":"2. Update Your Configs (if needed)","text":"<p>If your project uses a custom configuration file for URLs, make sure it points to your updated URL routing. For example, in <code>core/configs.py</code>:</p> core/configs.py<pre><code>URLs = 'core.urls.url_routing'\n</code></pre>"},{"location":"admin_panel/#3-run-your-application","title":"3. Run Your Application","text":"<p>Start your Panther application as usual:</p> <pre><code>panther run main:app\n</code></pre>"},{"location":"admin_panel/#4-access-the-admin-panel","title":"4. Access the Admin Panel","text":"<p>Open your browser and navigate to:</p> <p>http://127.0.0.1:8000/panel/</p> <p>You should see the Panther Admin Panel interface, where you can manage your database models. </p>"},{"location":"api/","title":"Panther API Guide","text":"<p>This guide assumes you have successfully set up your project and created your first CRUD following the First CRUD guide.</p> <p>In this guide, we discuss the features and structure of Panther's API system, including authentication, permissions, caching, throttling, middlewares, and more.</p>"},{"location":"api/#api-request-flow","title":"API Request Flow","text":"<p>The typical flow of an API request in Panther is as follows:</p> <pre><code>Middlewares\n\u251c\u2500\u2500 Method\n\u251c\u2500\u2500 Authentication\n\u251c\u2500\u2500 Permissions\n\u251c\u2500\u2500 Throttling\n\u251c\u2500\u2500 Validate Input\n\u251c\u2500\u2500 Get Response From Cache\n\u251c\u2500\u2500 Call Endpoint\n\u251c\u2500\u2500 Set Response To Cache\nMiddlewares\n</code></pre>"},{"location":"api/#input-model","title":"Input Model","text":"<p>You can validate incoming data using the <code>input_model</code> parameter. Pass a serializer to it, and Panther will send <code>request.data</code> to this serializer, placing the validated data in <code>request.validated_data</code>. As a result, <code>request.validated_data</code> will be an instance of your serializer.</p> <p>Note: <code>request.data</code> is validated only for 'POST', 'PUT', and 'PATCH' methods.</p> How do serializers work in Panther? <p>Refer to Serializer to learn more about serializers.</p> Function-Base APIClass-Base API app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\n\n@API(auth=True)\nasync def user_api(request: Request):\n    user = request.user\n    return Response(data=user, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\n\nclass UserAPI(GenericAPI):\n    auth = True\n\n    async def get(self, request: Request):\n        user = request.user\n        return Response(data=user, status_code=status.HTTP_200_OK)\n</code></pre>"},{"location":"api/#output-model","title":"Output Model","text":"<p>Use the <code>output_model</code> parameter to automatically serialize your API response data using a specified serializer. This ensures that the response structure is consistent and validated.</p> <p>Example Serializer:</p> app/serializers.py<pre><code>from panther.serializer import ModelSerializer\n\nclass UserSerializer(ModelSerializer):\n    ...\n</code></pre> Function-Base APIClass-Base API app/apis.py<pre><code>from panther.app import API\nfrom app.serializers import UserSerializer\n\n@API(output_model=UserSerializer)\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from panther.app import GenericAPI\nfrom app.serializers import UserSerializer\n\nclass UserAPI(GenericAPI):\n    output_model = UserSerializer\n    ...\n</code></pre> <p>Tip: Use <code>output_model</code> to ensure your API always returns data in the expected format. For OpenAPI documentation, see the <code>output_schema</code> section.</p>"},{"location":"api/#authentication","title":"Authentication","text":"<p>To ensure that each request contains a valid authentication header, set <code>auth=True</code>. Panther will look for the <code>AUTHENTICATION</code> class from your config and use its <code>authentication()</code> method for this purpose.</p> How do authentications work in Panther? <p>Refer to Authentications to learn more about authentications.</p> Function-Base APIClass-Base API app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\n@API(auth=True)\nasync def user_api(request: Request):\n    user = request.user\n    return Response(data=user, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nclass UserAPI(GenericAPI):\n    auth = True\n\n    async def get(self, request: Request):\n        user = request.user\n        return Response(data=user, status_code=status.HTTP_200_OK)\n</code></pre>"},{"location":"api/#method","title":"Method","text":"<p>You can specify which HTTP methods are allowed for an endpoint by setting <code>methods</code> in function-based APIs. Only the following methods are supported: <code>['GET', 'POST', 'PUT', 'PATCH', 'DELETE']</code>.</p> <p>If a method is not allowed, a 405 status code will be returned.</p> Function-Base APIClass-Base API app/apis.py<pre><code>from panther.app import API\nfrom panther.request import Request\n\n@API(methods=['GET', 'POST'])\nasync def user_api(request: Request):\n    match request.method:\n        case 'GET':\n            ...\n        case 'POST':\n            ...\n</code></pre> app/apis.py<pre><code>from panther.app import GenericAPI\n\nclass UserAPI(GenericAPI):  # (1)!\n    async def get(self):\n        ...\n\n    async def post(self):\n        ...\n</code></pre> <ol> <li>Now this class only accepts <code>GET</code> and <code>POST</code> requests.</li> </ol>"},{"location":"api/#permissions","title":"Permissions","text":"<p>You can implement your authorization logic using permission classes. Any class that inherits from <code>panther.permissions.BasePermission</code> or implements an <code>authorization()</code> method can be used as a permission class.</p> <p>Pass a list of permission classes to your API, and Panther will call each class's <code>authorization()</code> method. If any return <code>False</code>, a <code>panther.exceptions.AuthorizationAPIError</code> will be raised.</p> <p>The <code>authorization()</code> method should be an <code>async classmethod</code>.</p> <p>Example Permission Class:</p> app/permissions.py<pre><code>from panther.permissions import BasePermission\nfrom panther.request import Request\n\nclass CustomPermission(BasePermission):\n    @classmethod\n    async def authorization(cls, request: Request) -&gt; bool:\n        return True\n</code></pre> Function-Base APIClass-Base API app/apis.py<pre><code>from panther.app import API\nfrom app.permissions import CustomPermission\n\n@API(permissions=[CustomPermission])\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from panther.app import GenericAPI\nfrom app.permissions import CustomPermission\n\nclass UserAPI(GenericAPI):\n    permissions = [CustomPermission]\n    ...\n</code></pre>"},{"location":"api/#cache","title":"Cache","text":"<p>Responses can be cached for a specific amount of time per request or IP. Caching is only applied to <code>GET</code> requests. The response's headers, data, and status code will be cached.</p> <p>The cache is stored in Redis (if connected) or in memory. The cache key is based on the user ID or IP, request path, query parameters, and validated data:</p> <pre><code>'user_id or ip - request.path - hash of query param - request.validated_data'\n</code></pre> <p>The value of <code>cache</code> should be an instance of <code>datetime.timedelta()</code>.</p> Function-Base APIClass-Base API app/apis.py<pre><code>from datetime import timedelta\nfrom panther.app import API\n\n@API(cache=timedelta(minutes=10))\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from datetime import timedelta\nfrom panther.app import GenericAPI\n\nclass UserAPI(GenericAPI):\n    cache = timedelta(minutes=10)\n    ...\n</code></pre>"},{"location":"api/#throttling","title":"Throttling","text":"<p>You can throttle requests using the <code>Throttle</code> class, either globally via the <code>THROTTLING</code> config or per API. The <code>Throttle</code> class has two fields: <code>rate</code> and <code>duration</code>.</p> <p>If a user exceeds the allowed number of requests (<code>rate</code>) within the specified <code>duration</code>, they will receive a <code>429 Too Many Requests</code> response and be banned for the duration.</p> <p>When you set <code>throttling</code> on your API, it takes precedence over the default <code>THROTTLING</code>, and the default <code>THROTTLING</code> will not be executed.</p>"},{"location":"api/#setting-default-throttling","title":"Setting Default Throttling","text":"<pre><code>from datetime import timedelta\nfrom panther.throttling import Throttle\n\n# Users can only make 5 requests every minute\nTHROTTLING = Throttle(rate=5, duration=timedelta(minutes=1))\n</code></pre>"},{"location":"api/#throttling-per-api","title":"Throttling Per API","text":"Function-Base APIClass-Base API app/apis.py<pre><code>from datetime import timedelta\nfrom panther.app import API\nfrom panther.throttling import Throttle\n\n@API(throttling=Throttle(rate=5, duration=timedelta(minutes=1)))\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from datetime import timedelta\nfrom panther.app import GenericAPI\nfrom panther.throttling import Throttle\n\nclass UserAPI(GenericAPI):\n    throttling = Throttle(rate=5, duration=timedelta(minutes=1))\n    ...\n</code></pre>"},{"location":"api/#customization","title":"Customization","text":"<p>Throttling works with <code>request.user.id</code> or <code>request.client.ip</code>. You can customize its behavior by overriding <code>build_cache_key()</code>:</p> app/throttlings.py<pre><code>from panther.request import Request\nfrom panther.throttling import Throttle\n\nclass CustomThrottle(Throttle):\n    def build_cache_key(self, request: Request) -&gt; str:\n        ...\n</code></pre>"},{"location":"api/#middlewares","title":"Middlewares","text":"<p>You can pass custom middlewares to specific APIs.</p> <p>Example Middleware:</p> app/middlewares.py<pre><code>from panther.middlewares.base import HTTPMiddleware\nfrom panther.request import Request\nfrom panther.response import Response\n\nclass CustomMiddleware(HTTPMiddleware):\n    async def __call__(self, request: Request) -&gt; Response:\n        print('Hi')\n        response = await self.dispatch(request=request)\n        print('Bye')\n        return response\n</code></pre> Function-Base APIClass-Base API app/apis.py<pre><code>from panther.app import API\nfrom app.middlewares import CustomMiddleware \n\n@API(middlewares=[CustomMiddleware])\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from panther.app import GenericAPI\nfrom app.middlewares import CustomMiddleware \n\nclass UserAPI(GenericAPI):\n    middlewares = [CustomMiddleware]\n    ...\n</code></pre> How do middlewares work in Panther? <p>Refer to Middlewares to learn more about middlewares.</p>"},{"location":"api/#output-schema","title":"Output Schema","text":"<p>The <code>output_schema</code> attribute is used when generating OpenAPI (Swagger) documentation.  It should be an instance of <code>panther.openapi.OutputSchema</code>, which specifies the desired response data structure and status code.</p> <p>Example Serializer:</p> app/serializers.py<pre><code>from panther.serializer import ModelSerializer\n\nclass UserSerializer(ModelSerializer):\n    ...\n</code></pre> Function-Base APIClass-Base API app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.openapi import OutputSchema\nfrom app.serializers import UserSerializer\n\n@API(output_schema=OutputSchema(status_code=status.HTTP_201_CREATED, model=UserSerializer))\nasync def user_api():\n    ...\n</code></pre> app/apis.py<pre><code>from panther.app import GenericAPI\nfrom panther.openapi import OutputSchema\nfrom app.serializers import UserSerializer\n\nclass UserAPI(GenericAPI):\n    output_schema = OutputSchema(status_code=status.HTTP_201_CREATED, model=UserSerializer)\n    ...\n</code></pre> How does OpenAPI work in Panther? <p>Refer to OpenAPI to learn more about OpenAPI.</p>"},{"location":"authentications/","title":"Authentication in Panther","text":"<p>Authentication in Panther ensures that only authorized users can access your APIs and WebSocket connections. You can configure which authentication class to use in your <code>configs</code>.</p>"},{"location":"authentications/#how-authentication-works","title":"How Authentication Works","text":"<ul> <li>When <code>auth=True</code> is set for an API or WebSocket, Panther will use the configured authentication class to verify the user.</li> <li>If authentication fails, Panther raises <code>HTTP_401_UNAUTHORIZED</code>.</li> <li>The authenticated user is available as:</li> <li><code>request.user</code> in API views</li> <li><code>self.user</code> in WebSocket connections</li> </ul>"},{"location":"authentications/#built-in-authentication-classes","title":"Built-in Authentication Classes","text":"<p>Panther provides three built-in authentication classes, all based on JWT (JSON Web Token):</p>"},{"location":"authentications/#1-jwt-authentication","title":"1. JWT Authentication","text":"<ul> <li>Retrieves the JWT token from the <code>Authorization</code> header in the request.</li> <li>Expects the header format: <code>Authorization: Bearer &lt;token&gt;</code></li> <li>Decodes the token, validates it, and fetches the corresponding user.</li> <li>By default, uses <code>panther.db.models.BaseUser</code> as the user model unless you set <code>USER_MODEL</code> in your configs.</li> <li>Handles token revocation if Redis is connected (for logout and refresh scenarios).</li> </ul>"},{"location":"authentications/#example-usage","title":"Example usage","text":"<pre><code>AUTHENTICATION = 'panther.authentications.JWTAuthentication'\n</code></pre>"},{"location":"authentications/#jwt-configuration","title":"JWT Configuration","text":"<p>You can customize JWT behavior by setting <code>JWT_CONFIG</code> in your configs. Example:</p> core/configs.py<pre><code>from datetime import timedelta\nfrom panther.utils import load_env  \nfrom pathlib import Path\n\nBASE_DIR = Path(__name__).resolve().parent  \nenv = load_env(BASE_DIR / '.env')\n\nSECRET_KEY = env['SECRET_KEY']\n\nJWT_CONFIG = {\n    'key': SECRET_KEY,              # Secret key for signing tokens (default: `SECRET_KEY`)\n    'algorithm': 'HS256',           # Algorithm used for JWT (default: `'HS256'`)\n    'life_time': timedelta(days=2), # Access token lifetime (default: `timedelta(days=1)`)\n    'refresh_life_time': timedelta(days=10), # Refresh token lifetime (default: `2 * life_time`)\n}\n</code></pre>"},{"location":"authentications/#2-queryparam-jwt-authentication","title":"2. QueryParam JWT Authentication","text":"<ul> <li>Works like <code>JWTAuthentication</code>, but expects the token in the query parameters instead of headers.</li> <li>Useful for WebSocket authentication or scenarios where headers are not available.</li> <li>Pass the token as a query parameter:</li> <li>Example: <code>https://example.com?authorization=&lt;jwt_token&gt;</code></li> </ul>"},{"location":"authentications/#example-usage_1","title":"Example usage","text":"<pre><code>AUTHENTICATION = 'panther.authentications.QueryParamJWTAuthentication'\n</code></pre>"},{"location":"authentications/#3-cookie-jwt-authentication","title":"3. Cookie JWT Authentication","text":"<ul> <li>Works like <code>JWTAuthentication</code>, but expects the token in cookies.</li> <li>Looks for <code>access_token</code> in cookies for authentication.</li> <li>Optionally, can use <code>refresh_token</code> in cookies for token refresh.</li> <li>Pass the token in cookies:</li> <li>Example: <code>Cookies: access_token=&lt;jwt_token&gt;</code></li> </ul>"},{"location":"authentications/#example-usage_2","title":"Example usage","text":"<pre><code>AUTHENTICATION = 'panther.authentications.CookieJWTAuthentication'\n</code></pre>"},{"location":"authentications/#websocket-authentication","title":"WebSocket Authentication","text":"<p>For WebSocket connections, it is recommended to use <code>QueryParamJWTAuthentication</code> since headers are not always available. To enable this, set the following in your configs:</p> <pre><code>WS_AUTHENTICATION = 'panther.authentications.QueryParamJWTAuthentication'\n</code></pre>"},{"location":"authentications/#custom-authentication","title":"Custom Authentication","text":"<p>You can implement your own authentication logic by creating a custom class that inherits from <code>panther.authentications.BaseAuthentication</code>.</p>"},{"location":"authentications/#steps-to-create-a-custom-authentication-class","title":"Steps to create a custom authentication class:","text":"<ol> <li>Inherit from <code>BaseAuthentication</code></li> <li>Implement the class method: <pre><code>@classmethod\nasync def authentication(cls, request: Request | Websocket):\n    # Your authentication logic here\n    # Return an instance of USER_MODEL (default: BaseUser)\n    # Or raise panther.exceptions.AuthenticationAPIError on failure\n</code></pre></li> <li>Configure your custom authentication class in your configs: <pre><code>AUTHENTICATION = 'project_name.core.authentications.CustomAuthentication'\n</code></pre></li> </ol>"},{"location":"authentications/#error-handling","title":"Error Handling","text":"<ul> <li>If authentication fails, raise <code>panther.exceptions.AuthenticationAPIError</code> with an appropriate message.</li> <li>Panther will automatically handle and return a 401 Unauthorized response.</li> </ul>"},{"location":"authentications/#summary","title":"Summary","text":"<ul> <li>Choose and configure the appropriate authentication class for your use case.</li> <li>Use JWT configuration options to control token behavior.</li> <li>For WebSocket, prefer query parameter-based authentication.</li> <li>Implement custom authentication by inheriting from <code>BaseAuthentication</code> and overriding the <code>authentication</code> method.</li> </ul>"},{"location":"background_tasks/","title":"Background Tasks in Panther","text":"<p>Panther can run background tasks in a separate thread at startup if you set <code>BACKGROUND_TASKS</code> to <code>True</code> in your configuration.</p>"},{"location":"background_tasks/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Enable background tasks    In your <code>configs</code>, add:    <pre><code>BACKGROUND_TASKS = True\n</code></pre></p> </li> <li> <p>Create and submit a task <pre><code>from panther.background_tasks import BackgroundTask\n\ndef do_something(name: str, age: int):\n   print(f\"{name} is {age} years old.\")\n\nBackgroundTask(do_something, name='Ali', age=26).submit()\n</code></pre></p> <ul> <li>You must call <code>.submit()</code> to add the task to the queue.</li> <li>The task function can be synchronous or asynchronous.</li> </ul> </li> </ol>"},{"location":"background_tasks/#task-options","title":"Task Options","text":""},{"location":"background_tasks/#1-interval","title":"1. Interval","text":"<p>Control how many times a task runs:</p> <pre><code>BackgroundTask(do_something, name='Ali', age=26).interval(3).submit()\n</code></pre> <ul> <li>By default, tasks run once (<code>interval=1</code>).</li> <li>Use <code>interval(-1)</code> for infinite runs.</li> <li>Each interval is separated by the schedule you set (see below).</li> </ul>"},{"location":"background_tasks/#2-scheduling","title":"2. Scheduling","text":"<p>You can schedule tasks to run at specific intervals:</p> <ul> <li> <p>Every N seconds/minutes/hours/days/weeks: <pre><code>BackgroundTask(do_something, name='Ali', age=26).every_seconds(10).submit()\nBackgroundTask(do_something, name='Ali', age=26).every_minutes(5).submit()\nBackgroundTask(do_something, name='Ali', age=26).every_hours(2).submit()\nBackgroundTask(do_something, name='Ali', age=26).every_days(1).submit()\nBackgroundTask(do_something, name='Ali', age=26).every_weeks(1).submit()\n</code></pre></p> <ul> <li>Default value for each is <code>1</code> (e.g., every 1 minute).</li> </ul> </li> <li> <p>Custom values:   You can pass a custom value to any of the above, e.g., <code>every_days(4)</code> runs every 4 days.</p> </li> </ul>"},{"location":"background_tasks/#3-time-of-day","title":"3. Time of Day","text":"<p>Run a task at a specific time:</p> <pre><code>from datetime import time\nfrom panther.background_tasks import BackgroundTask\n\nBackgroundTask(do_something, name='Ali', age=26)\\\n    .every_days()\\\n    .at(time(hour=8, minute=0))\\\n    .submit()\n</code></pre> <ul> <li>The task will run when the system time matches the specified hour, minute, and second.</li> </ul>"},{"location":"background_tasks/#4-day-of-week","title":"4. Day of Week","text":"<p>Run a task on a specific day of the week:</p> <pre><code>from datetime import time\nfrom panther.background_tasks import BackgroundTask, WeekDay\n\nBackgroundTask(do_something, name='Ali', age=26)\\\n    .every_weeks(2)\\\n    .on(WeekDay.SUNDAY)\\\n    .at(time(hour=8))\\\n    .submit()\n</code></pre> <ul> <li>Valid days: <code>WeekDay.MONDAY</code>, <code>WeekDay.TUESDAY</code>, <code>WeekDay.WEDNESDAY</code>, <code>WeekDay.THURSDAY</code>, <code>WeekDay.FRIDAY</code>, <code>WeekDay.SATURDAY</code>, <code>WeekDay.SUNDAY</code>.</li> </ul>"},{"location":"background_tasks/#passing-arguments","title":"Passing Arguments","text":"<p>You can pass arguments to your task function as positional or keyword arguments:</p> <pre><code>BackgroundTask(do_something, name='Ali', age=26)\nBackgroundTask(do_something, 'Ali', age=26)\nBackgroundTask(do_something, 'Ali', 26)\n</code></pre>"},{"location":"background_tasks/#important-notes-best-practices","title":"Important Notes &amp; Best Practices","text":"<ul> <li>Task function can be synchronous or asynchronous.</li> <li>You must call <code>.submit()</code> to add the task to the background queue.</li> <li>Default interval is 1 (runs once). Use <code>.interval(-1)</code> for infinite runs.</li> <li>If you try to add a task before <code>BACKGROUND_TASKS</code> is enabled, it will be ignored and a warning will be logged.</li> <li>Each task runs in its own thread when triggered.</li> <li>Tasks are checked every second for their schedule.</li> </ul>"},{"location":"background_tasks/#example-task","title":"Example: Task","text":"<pre><code>import datetime\nfrom panther.background_tasks import BackgroundTask\n\nasync def hello(name: str):\n    print(f'Hello {name}')\n\n# Run 2 times, every 5 seconds\nBackgroundTask(hello, 'Ali').interval(2).every_seconds(5).submit()\n\n# Run forever, every day at 08:00\nBackgroundTask(hello, 'Saba').interval(-1).every_days().at(datetime.time(hour=8)).submit()\n</code></pre>"},{"location":"cors/","title":"CORSMiddleware","text":"<p><code>CORSMiddleware</code> is a middleware for Panther applications that handles Cross-Origin Resource Sharing (CORS). It automatically adds the appropriate CORS headers to all HTTP responses based on your configuration, and handles preflight (OPTIONS) requests.</p>"},{"location":"cors/#purpose","title":"Purpose","text":"<p>CORS is a security feature implemented by browsers to restrict web applications running on one origin from interacting with resources from a different origin. <code>CORSMiddleware</code> makes it easy to configure and manage CORS policies in your Panther application.</p>"},{"location":"cors/#configuration-options","title":"Configuration Options","text":"<p>Set the following variables in your Panther config file (e.g., <code>core/configs.py</code>) to control CORS behavior:</p> Config Variable Type Description Default ALLOW_ORIGINS list[str] List of allowed origins. Use <code>[\"*\"]</code> to allow all origins. <code>[\"*\"]</code> ALLOW_METHODS list[str] List of allowed HTTP methods. <code>[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\"]</code> ALLOW_HEADERS list[str] List of allowed request headers. Use <code>[\"*\"]</code> to allow all headers. <code>[\"*\"]</code> ALLOW_CREDENTIALS bool Whether to allow credentials (cookies, authorization headers, etc.). <code>False</code> EXPOSE_HEADERS list[str] List of headers that can be exposed to the browser. <code>[]</code> CORS_MAX_AGE int Number of seconds browsers can cache preflight responses. <code>600</code>"},{"location":"cors/#usage","title":"Usage","text":"<ol> <li>Set the desired CORS config variables in your config file.</li> <li>Add <code>'panther.middlewares.cors.CORSMiddleware'</code> to your <code>MIDDLEWARES</code> list.</li> </ol>"},{"location":"cors/#example-configuration","title":"Example Configuration","text":"e.g. core/configs.py<pre><code>ALLOW_ORIGINS = [\"https://example.com\", \"https://another.com\"]\nALLOW_METHODS = [\"GET\", \"POST\"]\nALLOW_HEADERS = [\"Content-Type\", \"Authorization\"]\nALLOW_CREDENTIALS = True\nEXPOSE_HEADERS = [\"X-Custom-Header\"]\nCORS_MAX_AGE = 3600\n\nMIDDLEWARES = [\n    # ... other middlewares ...\n    'panther.middlewares.cors.CORSMiddleware',\n]\n</code></pre>"},{"location":"cors/#how-it-works","title":"How It Works","text":"<ul> <li>For every request, the middleware adds the appropriate CORS headers to the response.</li> <li>For preflight (OPTIONS) requests, it returns a 204 response with the necessary headers.</li> <li>The headers are set based on your configuration, with sensible defaults if not specified.</li> </ul>"},{"location":"cors/#notes","title":"Notes","text":"<ul> <li>If you set <code>ALLOW_ORIGINS = [\"*\"]</code>, all origins are allowed.</li> <li>If you set <code>ALLOW_HEADERS = [\"*\"]</code>, all headers are allowed.</li> <li>If <code>ALLOW_CREDENTIALS</code> is <code>True</code>, the <code>Access-Control-Allow-Credentials</code> header is set to <code>true</code>.</li> <li>If you specify <code>EXPOSE_HEADERS</code>, those headers will be exposed to the browser.</li> </ul> <p>For more details, see the source code in <code>panther/middlewares/cors.py</code>.</p> <p>For a deeper understanding of CORS, you may also want to check the MDN Web Docs CORS Guide.</p>"},{"location":"database/","title":"Database Support in Panther","text":"<p>Panther natively supports two databases: <code>MongoDB</code> and <code>PantherDB</code>. However, you can also define your own custom database connections and queries.</p>"},{"location":"database/#configuration-structure","title":"Configuration Structure","text":"<p>Define your database configuration in the following format:</p> <pre><code>DATABASE = {\n    'engine': {\n        'class': 'address of engine',\n        'arg1': 'value1',\n        # ... additional arguments ...\n    },\n    'query': 'address of query class',  # Optional\n}\n</code></pre>"},{"location":"database/#notes","title":"Notes","text":"<ul> <li>Built-in supported engines:</li> <li><code>panther.db.connections.PantherDBConnection</code></li> <li><code>panther.db.connections.MongoDBConnection</code></li> <li>All values in <code>engine</code> (except <code>class</code>) are passed to the <code>__init__</code> method of the specified class.</li> <li>The <code>query</code> key is optional for the default supported engines, but you can customize it if needed.</li> </ul>"},{"location":"database/#pantherdb","title":"PantherDB","text":"<p>Example configuration for PantherDB:</p> <pre><code>DATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n        'path': BASE_DIR / 'database.pdb',  # Optional\n        'encryption': True  # Optional, default is False\n    }\n}\n</code></pre>"},{"location":"database/#notes_1","title":"Notes","text":"<ul> <li><code>path</code> is optional; you can customize the directory and filename of your database.</li> <li><code>encryption</code> is optional and defaults to <code>False</code>.</li> <li>The <code>cryptography</code> package is required if you set <code>encryption</code> to <code>True</code>.</li> </ul>"},{"location":"database/#mongodb","title":"MongoDB","text":"<p>Example configuration for MongoDB:</p> <pre><code>DATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.MongoDBConnection',\n        'host': 'mongodb://127.0.0.1:27017/database_name'\n    }\n}\n</code></pre>"},{"location":"database/#notes_2","title":"Notes","text":"<ul> <li>The parameters for the engine are the same as those for <code>pymongo.MongoClient</code>. See the PyMongo documentation for details.</li> </ul>"},{"location":"database/#how-does-it-work","title":"How Does It Work?","text":"<ul> <li>Panther creates a database connection based on the <code>DATABASE</code> configuration you define in your configs.</li> <li>You can access this connection through your models, or directly via:   <pre><code>from panther.db.connections import db\n</code></pre></li> </ul>"},{"location":"deployment/","title":"Deploying Panther Applications","text":"<p>Panther is an ASGI-compatible web framework, which means you can deploy your Panther app using any ASGI server, such as Uvicorn, Granian, Daphne, or others. This guide covers best practices and options for deploying your Panther application in production.</p>"},{"location":"deployment/#1-production-ready-asgi-servers","title":"1. Production-Ready ASGI Servers","text":"<p>While Panther comes with a convenient CLI, you are not limited to it. You can use any ASGI server to run your app:</p> <ul> <li>Uvicorn (default, recommended)</li> <li>Granian</li> <li>Daphne</li> <li>Hypercorn</li> <li>Any other ASGI-compliant server</li> </ul>"},{"location":"deployment/#example-using-uvicorn-directly","title":"Example: Using Uvicorn Directly","text":"<pre><code>uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre> <ul> <li><code>main:app</code> refers to your application instance (e.g., <code>app = Panther(...)</code> in <code>main.py</code>).</li> <li>Adjust <code>--workers</code> for your server's CPU count.</li> </ul>"},{"location":"deployment/#example-using-gunicorn-with-uvicorn-workers","title":"Example: Using Gunicorn with Uvicorn Workers","text":"<p>For robust process management and multiple workers:</p> <pre><code>gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app\n</code></pre>"},{"location":"deployment/#2-using-the-panther-cli","title":"2. Using the Panther CLI","text":"<p>Panther provides a built-in CLI for development and deployment. The command:</p> <pre><code>panther run main:app --reload\n</code></pre> <p>is an alias for running Uvicorn with your Panther app. You can use all Uvicorn options with this command.</p> <ul> <li><code>--reload</code> is for development (auto-reloads on code changes).</li> <li>Omit <code>--reload</code> for production.</li> </ul> <p>Note: For advanced deployment, prefer running Uvicorn (or another ASGI server) directly, as shown above.</p>"},{"location":"deployment/#3-environment-variables-configuration","title":"3. Environment Variables &amp; Configuration","text":"<ul> <li>Set environment variables (e.g., <code>PORT</code>, <code>HOST</code>, <code>DATABASE_URL</code>) as needed for your deployment environment.</li> <li>Use a process manager (e.g., systemd, supervisor, pm2, or Docker (recomended)) to keep your app running and restart on failure.</li> </ul>"},{"location":"deployment/#4-static-files-reverse-proxy","title":"4. Static Files &amp; Reverse Proxy","text":"<p>Panther does not serve static files in production. Use a reverse proxy (like Nginx or Caddy) to:</p> <ul> <li>Serve static files (JS, CSS, images)</li> <li>Forward requests to your ASGI server (Uvicorn, etc.)</li> <li>Handle HTTPS/SSL termination</li> </ul> <p>Example Nginx config: <pre><code>location / {\n    proxy_pass http://127.0.0.1:8000;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n}\n</code></pre></p>"},{"location":"deployment/#5-websocket-multiple-workers","title":"5. WebSocket &amp; Multiple Workers","text":"<p>If your app uses WebSockets and you want to run multiple workers, configure Redis for pub/sub support (see Redis Integration). Alternatively, use the <code>--preload</code> flag with Gunicorn for basic multi-worker support (see WebSocket docs).</p>"},{"location":"deployment/#6-example-docker-deployment","title":"6. Example: Docker Deployment","text":"<p>Panther can be efficiently containerized using a multi-stage Docker build and the uv package manager, which is significantly faster and more reliable than pip. This approach results in smaller, more secure images and faster build times.</p>"},{"location":"deployment/#advantages-of-multi-stage-uv","title":"Advantages of Multi-Stage &amp; uv","text":"<ul> <li>Smaller final image size: Only production dependencies and app code are included.</li> <li>Faster dependency installation: <code>uv</code> is much faster than <code>pip</code> and supports modern lockfiles.</li> <li>Better security: Build tools and caches are left behind in the builder stage.</li> <li>Cleaner builds: No unnecessary files in the final image.</li> </ul>"},{"location":"deployment/#example-multi-stage-dockerfile-with-uv","title":"Example Multi-Stage Dockerfile with uv","text":"<pre><code>FROM python:3.12 AS builder\nWORKDIR /app\nRUN python -m venv /opt/venv\nRUN pip install --no-cache-dir uv\nCOPY requirements.txt .\nRUN /opt/venv/bin/uv pip install -r requirements.txt --system\n\nFROM python:3.12-slim AS production\nENV PYTHONUNBUFFERED=1\nENV PATH=\"/opt/venv/bin:$PATH\"\nCOPY --from=builder /opt/venv /opt/venv\nWORKDIR /app\nCOPY . /app\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"events/","title":"Application Events","text":"<p>Panther provides a simple way to execute custom logic during your application's lifecycle using event decorators. You can hook into the startup and shutdown phases to run code when your app starts or stops.</p>"},{"location":"events/#startup-event","title":"Startup Event","text":"<p>To run code when your application starts, use the <code>@Event.startup</code> decorator:</p> events.py<pre><code>from panther.events import Event\n\n@Event.startup\ndef do_something_on_startup():\n    print('Hello, I am at startup')\n</code></pre> <p>You can define multiple startup event handlers. They will be executed in the order they are registered.</p>"},{"location":"events/#shutdown-event","title":"Shutdown Event","text":"<p>To run code when your application is shutting down, use the <code>@Event.shutdown</code> decorator:</p> events.py<pre><code>from panther.events import Event\n\n@Event.shutdown\ndef do_something_on_shutdown():\n    print('Good Bye, I am at shutdown')\n</code></pre> <p>You can define multiple shutdown event handlers as well.</p>"},{"location":"events/#additional-notes","title":"Additional Notes","text":"<ul> <li>Multiple Handlers: You can register multiple functions for both <code>startup</code> and <code>shutdown</code> events. All will be called.</li> <li>Sync &amp; Async Support: Event handlers can be either synchronous or asynchronous functions.</li> <li>Use Cases: Common use cases include initializing resources (like database connections) on startup and cleaning up resources on shutdown.</li> </ul>"},{"location":"first_crud/","title":"First CRUD","text":"<p>We assume you have successfully set up your project following the Introduction guide.</p> <p>In this guide, we will create a <code>CRUD</code> (<code>Create</code>, <code>Retrieve</code>, <code>Update</code>, and <code>Delete</code>) API for managing <code>Book</code> entities.</p>"},{"location":"first_crud/#project-structure","title":"Project Structure","text":"<p>The final structure of your project will be as follows: <pre><code>.\n\u251c\u2500\u2500 app\n\u2502     \u251c\u2500\u2500 apis.py\n\u2502     \u251c\u2500\u2500 models.py\n\u2502     \u251c\u2500\u2500 serializers.py\n\u2502     \u2514\u2500\u2500 urls.py\n\u2514\u2500\u2500 core\n      \u251c\u2500\u2500 configs.py\n      \u2514\u2500\u2500 urls.py\n</code></pre></p>"},{"location":"first_crud/#configuring-the-database","title":"Configuring the Database","text":"<p>How does the database work in Panther?</p> <p>Refer to Database to learn about supported databases and their functionality.</p> <p>Configure the <code>DATABASE</code> settings in <code>core/configs.py</code>. In this guide, we will use <code>PantherDB</code>.</p> <p>PantherDB is a simple, file-based, document-oriented database.</p> core/configs.py<pre><code>DATABASE = {\n    'engine': {\n        'class': 'panther.db.connections.PantherDBConnection',\n    }\n}\n</code></pre>"},{"location":"first_crud/#defining-the-model","title":"Defining the Model","text":"<p>How do models work in Panther?</p> <p>Refer to Models to learn more about defining models and how they function.</p> <p>Create a model named <code>Book</code> in <code>app/models.py</code>:</p> app/models.py<pre><code>from panther.db import Model\n\n\nclass Book(Model):\n    name: str\n    author: str\n    pages_count: int\n</code></pre>"},{"location":"first_crud/#defining-urls","title":"Defining URLs","text":"<p>How do URLs work in Panther?</p> <p>Refer to URLs to learn more about URL definitions.</p> <p>The base <code>urls</code> configuration should include all application URLs.</p> <p>core/urls.py<pre><code>from app.urls import urls as app_urls\n\n\nurls = {\n    '/': app_urls,\n}\n</code></pre> In <code>app/urls.py</code>, define the <code>Book</code> API URLs:</p> Function-BaseClass-Base API/ Generic API (Beta) app/urls.py<pre><code>from app.apis import book_api, single_book_api\n\nurls = {\n    'book/': book_api,\n    'book/&lt;book_id&gt;/': single_book_api,\n}\n</code></pre> app/urls.py<pre><code>from app.apis import BookAPI, SingleBookAPI\n\nurls = {\n    'book/': BookAPI,\n    'book/&lt;book_id&gt;/': SingleBookAPI,\n}\n</code></pre>"},{"location":"first_crud/#defining-the-serializer","title":"Defining the Serializer","text":"<p>How do serializers work in Panther?</p> <p>Refer to Serializer to learn more about available serializers.</p> <p>Serializers transform data between the application and API requests.</p> Function-Base/ Class-Base APIGeneric API (Beta) <p>The serializer can be inherited from <code>ModelSerializer</code> or <code>pydantic.BaseModel</code></p> <p>app/serializers.py<pre><code>from panther.serializer import ModelSerializer\n\nfrom app.models import Book\n\nclass BookSerializer(ModelSerializer):\n    class Config:\n        model = Book\n        fields = ['name', 'author', 'pages_count']\n</code></pre> or</p> app/serializers.py<pre><code>import pydantic\n\nfrom app.models import Book\n\nclass BookSerializer(pydantic.BaseModel):\n    name: str\n    author: str\n    pages_count: int\n</code></pre> <p>The serializer should be inherited from <code>ModelSerializer</code> to be used in <code>GenericAPI</code>.</p> app/serializers.py<pre><code>from panther.serializer import ModelSerializer\n\nfrom app.models import Book\n\nclass BookSerializer(ModelSerializer):\n    class Config:\n        model = Book\n        fields = ['name', 'author', 'pages_count']\n</code></pre>"},{"location":"first_crud/#apis","title":"APIs","text":"<p>How do APIs work in Panther?</p> <p>Refer to API to learn more about API types and their usage.</p>"},{"location":"first_crud/#create","title":"Create","text":"Function-Base APIClass-Base APIGeneric API (Beta) app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer, methods=['POST'])\nasync def book_api(request: Request):\n    body: BookSerializer = request.validated_data\n    book: Book = await Book.insert_one(\n        name=body.name,\n        author=body.author,\n        pages_count=body.pages_count,\n    )\n    return Response(data=book, status_code=status.HTTP_201_CREATED)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def post(self, request: Request):\n        body: BookSerializer = request.validated_data\n        book = await Book.insert_one(\n            name=body.name,\n            author=body.author,\n            pages_count=body.pages_count,\n        )\n        return Response(data=book, status_code=status.HTTP_201_CREATED)\n</code></pre> app/apis.py<pre><code>from panther.app import CreateAPI\n\nfrom app.serializers import BookSerializer\n\n\nclass BookAPI(CreateAPI):\n    input_model = BookSerializer\n</code></pre>"},{"location":"first_crud/#list","title":"List","text":"Function-Base APIClass-Base APIGeneric API (Beta) app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\n@API(input_model=BookSerializer, methods=['POST', 'GET'])\nasync def book_api(request: Request):\n    ...\n    if request.method == 'GET':\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nfrom app.serializers import BookSerializer\nfrom app.models import Book\n\n\nclass BookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def get(self):\n        books = await Book.find()\n        return Response(data=books, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther.generics import CreateAPI, ListAPI\nfrom panther.pagination import Pagination\nfrom panther.request import Request\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\nclass BookAPI(CreateAPI, ListAPI):\n    input_model = BookSerializer\n    pagination = Pagination  #(1)!\n    search_fields = ['name', 'author']  #(2)!\n    filter_fields = ['name', 'author']  #(3)!\n    sort_fields = ['name', 'pages_count']  #(4)!\n\n    async def cursor(self, request: Request, **kwargs):\n        return await Book.find()\n</code></pre> <ol> <li><code>Pagination</code> class will look for the <code>limit</code> and <code>skip</code> in the <code>query params</code> and paginate your response and then return it on its own response template.</li> <li>The query will be changed and looking for the value of the <code>search</code> query param in these fields, e.g. query param is the <code>?search=TheLittlePrince</code>, we will looking for the Book with <code>name</code> or <code>author</code> of <code>TheLittlePrince</code>.</li> <li>It will look for each value of the <code>filter_fields</code> in the <code>query params</code> and query on them,  e.g. <code>?name=Something&amp;author=Ali</code>, it will looks for Book that its <code>author</code> is <code>Ali</code> and its <code>name</code> is <code>Something</code>.</li> <li>The query will be sortalbe with the fields which is in <code>sort_fields</code>.</li> </ol>"},{"location":"first_crud/#retrieve","title":"Retrieve","text":"Function-Base APIClass-Base APIGeneric API (Beta) app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\n@API(methods=['GET'])\nasync def single_book_api(request: Request, book_id: int):\n    if book := await Book.find_one(id=book_id):\n        return Response(data=book, status_code=status.HTTP_200_OK)\n    return Response(data={'detail': 'Book not found'}, status_code=status.HTTP_400_BAD_REQUEST)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\nclass SingleBookAPI(GenericAPI):\n    async def get(self, book_id: int):\n        if book := await Book.find_one(id=book_id):\n            return Response(data=book, status_code=status.HTTP_200_OK)\n        return Response(data={'detail': 'Book not found'}, status_code=status.HTTP_400_BAD_REQUEST)\n</code></pre> app/apis.py<pre><code>from panther.generics import RetrieveAPI\nfrom panther.request import Request\n\nfrom app.models import Book\n\n\nclass SingleBookAPI(RetrieveAPI):\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre>"},{"location":"first_crud/#update","title":"Update","text":"Function-Base APIClass-Base APIGeneric API (Beta) app/apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer \n\n\n@API(input_model=BookSerializer, methods=['GET', 'PUT'])\nasync def single_book_api(request: Request, book_id: int):\n    ...\n    if request.method == 'PUT':            \n        is_updated = await Book.update_one({'id': book_id}, request.validated_data.model_dump())\n        data = {'is_updated': is_updated}\n        return Response(data=data, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\nclass SingleBookAPI(GenericAPI):\n    input_model = BookSerializer\n\n    async def put(self, request: Request, book_id: int):\n        is_updated = await Book.update_one({'id': book_id}, request.validated_data.model_dump())\n        data = {'is_updated': is_updated}\n        return Response(data=data, status_code=status.HTTP_200_OK)\n</code></pre> app/apis.py<pre><code>from panther.generics import RetrieveAPI\nfrom panther.request import Request\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\nclass SingleBookAPI(RetrieveAPI, UpdateAPI):\n    input_model = BookSerializer\n\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre>"},{"location":"first_crud/#delete","title":"Delete","text":"Function-Base APIClass-Base APIGeneric API (Beta) apis.py<pre><code>from panther import status\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer \n\n\n@API(input_model=BookSerializer, methods=['GET', 'PUT', 'DELETE'])\nasync def single_book_api(request: Request, book_id: int):\n    ...\n    if request.method == 'DELETE':\n        await Book.delete_one(id=book_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre> apis.py<pre><code>from panther import status\nfrom panther.app import GenericAPI\nfrom panther.response import Response\n\nfrom app.models import Book\n\n\nclass SingleBookAPI(GenericAPI):\n    async def delete(self, book_id: int):\n        await Book.delete_one(id=book_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre> apis.py<pre><code>from panther.generics import RetrieveAPI\nfrom panther.request import Request\n\nfrom app.models import Book\nfrom app.serializers import BookSerializer\n\n\nclass SingleBookAPI(RetrieveAPI, UpdateAPI, DeleteAPI):\n    input_model = BookSerializer\n\n    async def object(self, request: Request, **kwargs):\n        return await Book.find_one_or_raise(id=kwargs['book_id'])\n</code></pre> <p>With this, you now have a complete CRUD API implementation for the <code>Book</code> entity.</p>"},{"location":"log_queries/","title":"Query Performance Logging","text":"<p>Panther provides built-in query performance monitoring that logs the execution time of each database query when enabled. </p>"},{"location":"log_queries/#configuration","title":"Configuration","text":"<p>To enable query performance logging, set the <code>LOG_QUERIES</code> configuration option to <code>True</code>:</p> <pre><code>LOG_QUERIES = True  # Default is False\n</code></pre>"},{"location":"log_queries/#how-it-works","title":"How It Works","text":"<p>When <code>LOG_QUERIES</code> is enabled, Panther automatically:</p> <ul> <li>Measures execution time for every database query</li> <li>Logs performance data to <code>logs/query.log</code></li> <li>Includes query details such as method name and execution time in milliseconds</li> </ul>"},{"location":"log_queries/#log-format","title":"Log Format","text":"<p>Each log entry follows this format:</p> <pre><code>INFO: | [Timestamp] | [Query] [Method] takes [Duration] ms\n</code></pre>"},{"location":"log_queries/#example-log-entries","title":"Example Log Entries","text":"<pre><code>INFO: | 2023-03-19 20:37:27 | [Query] User.insert_one() takes 1.612 ms\nINFO: | 2023-03-19 20:37:28 | [Query] User.find() takes 45.234 ms\nINFO: | 2023-03-19 20:37:29 | [Query] Post.update_one() takes 12.891 ms\nINFO: | 2023-03-19 20:37:30 | [Query] Comment.delete_one() takes 3.445 ms\n</code></pre>"},{"location":"log_queries/#use-cases","title":"Use Cases","text":"<p>Query logging is particularly useful for:</p> <ul> <li>Development: Identifying slow queries during development</li> <li>Debugging: Troubleshooting performance issues</li> <li>Optimization: Finding bottlenecks in database operations</li> <li>Monitoring: Tracking query performance over time</li> </ul>"},{"location":"log_queries/#performance-considerations","title":"Performance Considerations","text":"<p>Keep <code>LOG_QUERIES = False</code> in production environments for optimal performance.</p> <p>Query logging adds a small overhead to each database operation, which can impact application performance under high load.</p>"},{"location":"middlewares/","title":"Middlewares in Panther","text":"<p>Middlewares allow you to process requests and responses globally or for all or specific APIs. They are useful for tasks such as logging, timing, and other cross-cutting concerns.</p>"},{"location":"middlewares/#global-middlewares","title":"Global Middlewares","text":"<p>To apply middlewares globally, define a <code>MIDDLEWARES</code> list in your configs. Each item can be either a string (dotted path to the middleware class) or the class itself (useful for single-file applications):</p> <pre><code>class Middleware(HTTPMiddleware):\n    pass\n\nMIDDLEWARES = [\n    'core.middlewares.MyMiddleware',  # Import by dotted path\n    Middleware,                       # Or directly by class\n]\n</code></pre>"},{"location":"middlewares/#per-api-middlewares","title":"Per-API Middlewares","text":"<p>You can assign middlewares to specific APIs, either class-based or function-based:</p> apis.py<pre><code>from panther.app import API, GenericAPI\nfrom panther.middlewares import HTTPMiddleware\n\nclass Middleware(HTTPMiddleware):\n    pass\n\n# Class-Based API\nclass MyAPI(GenericAPI):\n    middlewares = [Middleware]\n\n# Function-Based API\n@API(middlewares=[Middleware])\ndef my_api():\n    pass\n</code></pre>"},{"location":"middlewares/#middleware-execution-order","title":"Middleware Execution Order","text":"<p>Middlewares are executed in the following order:</p> <ol> <li>Global middlewares: <code>__call__()</code> (enter)</li> <li>Per-API middlewares: <code>__call__()</code> (enter)</li> <li>Per-API middlewares: <code>dispatch</code> (return)</li> <li>Global middlewares: <code>dispatch</code> (return)</li> </ol>"},{"location":"middlewares/#creating-custom-middlewares","title":"Creating Custom Middlewares","text":""},{"location":"middlewares/#types-of-middlewares","title":"Types of Middlewares","text":"<p>Panther provides two types of middleware base classes:</p> <ul> <li><code>HTTPMiddleware</code>: For HTTP requests only</li> <li><code>WebsocketMiddleware</code>: For WebSocket connections only</li> </ul> <p>Make sure to inherit from the correct base class:</p> <pre><code># For HTTP requests\nfrom panther.middlewares import HTTPMiddleware\n\n# For WebSocket connections\nfrom panther.middlewares import WebsocketMiddleware\n</code></pre>"},{"location":"middlewares/#implementing-a-middleware","title":"Implementing a Middleware","text":"<ul> <li>Create a class inheriting from <code>HTTPMiddleware</code> or <code>WebsocketMiddleware</code>.</li> <li>Implement an asynchronous <code>__call__</code> method.</li> <li>Always return either <code>await self.dispatch(...)</code> or a <code>Response</code>/<code>GenericWebsocket</code> instance at the end of <code>__call__()</code>.</li> </ul>"},{"location":"middlewares/#example-http-middleware","title":"Example: HTTP Middleware","text":"middlewares.py<pre><code>from datetime import datetime\nfrom panther.middlewares.base import HTTPMiddleware\nfrom panther.request import Request\nfrom panther.response import Response\n\nclass CustomMiddleware(HTTPMiddleware):\n    async def __call__(self, request: Request) -&gt; Response:\n        start_time = datetime.now()\n        response = await self.dispatch(request=request)\n        duration = datetime.now() - start_time\n        print(f'Request took {duration.total_seconds()} seconds')\n        return response\n</code></pre>"},{"location":"middlewares/#example-websocket-middleware","title":"Example: WebSocket Middleware","text":"middlewares.py<pre><code>from datetime import datetime\nfrom panther.middlewares.base import WebsocketMiddleware\nfrom panther.websocket import GenericWebsocket, Websocket\n\nclass TimerMiddleware(WebsocketMiddleware):\n    async def __call__(self, connection: Websocket) -&gt; GenericWebsocket:\n        start_time = datetime.now()\n        response = await self.dispatch(connection=connection)\n        duration = datetime.now() - start_time\n        print(f'Connection lasted {duration.total_seconds()} seconds')\n        return response\n</code></pre>"},{"location":"middlewares/#built-in-middlewares","title":"Built-in Middlewares","text":"<p>Panther provides several built-in middlewares to help with common tasks. Below are the available options and how to use them:</p>"},{"location":"middlewares/#cors-middleware","title":"CORS Middleware","text":"<ul> <li>Purpose: Enables Cross-Origin Resource Sharing (CORS) for your APIs.</li> <li>Usage: Add <code>panther.middlewares.CORSMiddleware</code> to your global <code>MIDDLEWARES</code> list.</li> <li>Configuration: Requires specific global settings. See the CORS Middleware documentation for configuration details.</li> </ul>"},{"location":"middlewares/#monitoring-middleware","title":"Monitoring Middleware","text":"<ul> <li>Purpose: Logs request and connection data for monitoring and analytics.</li> <li>Usage: Add <code>panther.middlewares.MonitoringMiddleware</code> to your global <code>MIDDLEWARES</code> list.</li> <li>Note: This middleware or <code>WebsocketMonitoringMiddleware</code> is required if you want to use the <code>panther monitor</code> command.</li> </ul>"},{"location":"middlewares/#websocket-monitoring-middleware","title":"WebSocket Monitoring Middleware","text":"<ul> <li>Purpose: Similar to <code>MonitoringMiddleware</code>, but specifically logs data for WebSocket connections.</li> <li>Usage: Add <code>panther.middlewares.WebsocketMonitoringMiddleware</code> to your global <code>MIDDLEWARES</code> list if you want to monitor WebSocket traffic.</li> <li>Note: This middleware or <code>MonitoringMiddleware</code> is required if you want to use the <code>panther monitor</code> command.</li> </ul>"},{"location":"middlewares/#tips","title":"Tips","text":"<ul> <li>Use global middlewares for logic that should apply to all requests.</li> <li>Use per-API middlewares for logic specific to certain endpoints.</li> <li>Always ensure your <code>__call__</code> method is asynchronous and returns the appropriate value.</li> </ul>"},{"location":"model/","title":"Panther Models","text":"<p>Panther models allow you to define your data schema and interact with the database using Python classes. They are built on top of <code>pydantic.BaseModel</code> and extend its functionality with database query capabilities.</p>"},{"location":"model/#creating-a-model","title":"Creating a Model","text":"<p>To create a Panther model, define a class that inherits from <code>panther.db.Model</code>:</p> app/models.py<pre><code>from panther.db import Model\n\nclass User(Model):\n    username: str\n    age: int\n    is_active: bool\n</code></pre> <p>Panther models inherit from both <code>pydantic.BaseModel</code> and <code>panther.db.Query</code>, giving you access to data validation and database queries.</p>"},{"location":"model/#defining-attributes","title":"Defining Attributes","text":"<p>You can define model attributes (columns) using Python type hints. Each attribute type is handled as follows:</p>"},{"location":"model/#general-types","title":"General Types","text":"<ul> <li>str, int, bool: Saved in the database as-is.</li> </ul> <p>Example: app/models.py<pre><code>from panther.db import Model\n\nclass Product(Model):\n    name: str\n    price: int\n    in_stock: bool\n</code></pre></p>"},{"location":"model/#list","title":"List","text":"<ul> <li>list: Each item in the list is processed according to its type. The child type can be a primitive, a <code>pydantic.BaseModel</code>, or another <code>Model</code>.</li> </ul> <p>Example: app/models.py<pre><code>from pydantic import BaseModel\nfrom panther.db import Model\n\nclass Book(BaseModel):\n    title: str\n    author: str\n    tags: list[str]\n\nclass Library(Model):\n    name: str\n    books: list[Book]\n\nclass School(Model):\n    name: str\n    libraries: list[Library]\n</code></pre></p>"},{"location":"model/#dictionary","title":"Dictionary","text":"<ul> <li>dict: Each value in the dictionary is processed according to its type. Only plain <code>dict</code> is supported (not typed dicts like <code>dict[str, int]</code>).</li> </ul> <p>Example: app/models.py<pre><code>from panther.db import Model\n\nclass Config(Model):\n    settings: dict\n</code></pre></p>"},{"location":"model/#nested-models","title":"Nested Models","text":"<ul> <li>pydantic.BaseModel: Treated like a dictionary, but with type information for each item. Each item is processed according to its type.</li> </ul> <p>Example: app/models.py<pre><code>from pydantic import BaseModel\nfrom panther.db import Model\n\nclass Address(BaseModel):\n    city: str\n    zipcode: str\n\nclass Customer(Model):\n    name: str\n    address: Address\n</code></pre></p>"},{"location":"model/#foreign-keys","title":"Foreign Keys","text":"<ul> <li>panther.db.Model: Treated as a foreign key relationship.<ol> <li>The related model's value is stored in the database.</li> <li>Its <code>id</code> is saved in the main document (table).</li> <li>This process is handled automatically, so you always have access to all attributes of the related model.</li> <li>Panther retrieves the corresponding value from the database and returns it as a fully populated model instance.</li> </ol> </li> </ul> <p>Example: app/models.py<pre><code>from panther.db import Model\n\nclass Department(Model):\n    name: str\n\nclass Employee(Model):\n    name: str\n    department: Department\n</code></pre></p>"},{"location":"model/#optional-attributes","title":"Optional Attributes","text":"<ul> <li>You can make an attribute optional by using a union with <code>None</code> (e.g., <code>str | None</code>) and providing a default value (e.g., <code>= None</code>).</li> <li>If you make an attribute optional, you must assign a default value.</li> </ul> <p>Example: app/models.py<pre><code>from panther.db import Model\n\nclass Article(Model):\n    title: str\n    summary: str | None = None  # Optional attribute with default value\n</code></pre></p>"},{"location":"open_api/","title":"OpenAPI Integration in Panther","text":"<p>Panther automatically generates an OpenAPI specification for your APIs. This makes it easy to document, test, and share your API endpoints.</p>"},{"location":"open_api/#how-to-enable-openapi-in-your-project","title":"How to Enable OpenAPI in Your Project","text":"<p>Panther provides multiple OpenAPI UI options that you can import directly into your project. You don't need to add the bundled <code>openapi.urls.url_routing</code> - instead, you can choose the specific UI component you prefer.</p>"},{"location":"open_api/#available-openapi-ui-components","title":"Available OpenAPI UI Components","text":"<p>Panther offers several OpenAPI UI options available in <code>panther.openapi.views</code>:</p> <ul> <li><code>ScalarOpenAPI</code> - Modern, customizable API documentation UI</li> <li><code>SwaggerOpenAPI</code> - Classic Swagger UI interface</li> <li><code>RedocOpenAPI</code> - Clean, responsive documentation interface</li> <li><code>RapiDocOpenAPI</code> - Fast, lightweight API documentation</li> <li><code>SpotlightOpenAPI</code> - Stoplight Elements integration</li> </ul>"},{"location":"open_api/#adding-openapi-to-your-project","title":"Adding OpenAPI to Your Project","text":"<p>You can import and use any of these UI components directly in your URL configuration:</p> urls.py<pre><code>from panther.openapi.views import ScalarOpenAPI, SwaggerOpenAPI, RedocOpenAPI\n\nurl_routing = {\n    'docs/scalar/': ScalarOpenAPI,    # Modern UI at /docs/scalar/\n    'docs/swagger/': SwaggerOpenAPI,  # Classic Swagger at /docs/swagger/\n    'docs/redoc/': RedocOpenAPI,      # Clean interface at /docs/redoc/\n    # Other urls\n}\n</code></pre>"},{"location":"open_api/#alternative-using-all-ui-components","title":"Alternative: Using All UI Components","text":"<p>If you want to include all OpenAPI UI options at once, you can still use the bundled routing:</p> urls.py<pre><code>from panther.openapi.urls import url_routing as openapi_url_routing\n\nurl_routing = {\n    'docs/': openapi_url_routing,  # Includes all UI options\n    # Other urls\n}\n</code></pre> <p>This will make the following endpoints available:</p> <ul> <li><code>/docs/scalar/</code> - Scalar UI</li> <li><code>/docs/swagger/</code> - Swagger UI  </li> <li><code>/docs/redoc/</code> - ReDoc UI</li> <li><code>/docs/rapidoc/</code> - RapiDoc UI</li> <li><code>/docs/spotlight/</code> - Spotlight UI</li> </ul>"},{"location":"open_api/#how-panther-determines-response-models-and-status-codes","title":"How Panther Determines Response Models and Status Codes","text":"<p>Panther follows a specific logic to generate the OpenAPI YAML for your APIs:</p> <ol> <li><code>output_schema</code>: Panther first looks for an <code>output_schema</code> attribute to generate the OpenAPI documentation. This is the recommended and most accurate way to specify your response model and status code.</li> <li><code>output_model</code>: If <code>output_schema</code> does not exist, Panther looks for an <code>output_model</code> attribute to generate the response type. It will also attempt to extract the status code from your source code.</li> <li>Source Code Analysis: If neither <code>output_schema</code> nor <code>output_model</code> is available, Panther tries to extract the response data and status code directly from your source code using static analysis with <code>ast</code>.</li> </ol> <p>For best results and more accurate documentation, always specify <code>output_schema</code> in your APIs.</p>"},{"location":"open_api/#how-panther-generates-openapi-docs","title":"How Panther Generates OpenAPI Docs","text":"<p>Panther inspects your API views for an <code>output_schema</code> attribute. This attribute should be an instance of <code>panther.openapi.OutputSchema</code>, which describes the response model and status code for your endpoint.</p> <ul> <li><code>model</code> in <code>OutputSchema</code> can be either a <code>pydantic.BaseModel</code> or a <code>panther.serializer.ModelSerializer</code>.</li> <li><code>status_code</code> should be an integer (e.g., <code>status.HTTP_200_OK</code>).</li> </ul>"},{"location":"open_api/#example","title":"Example","text":"Function-Base APIClass-Base API <pre><code>from pydantic import BaseModel\nfrom panther import status\nfrom panther.app import API\nfrom panther.openapi import OutputSchema\n\nclass UserSerializer(BaseModel):\n    username: str\n    age: int\n\n@API(output_schema=OutputSchema(model=UserSerializer, status_code=status.HTTP_200_OK))\ndef user_api():\n    ...\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom panther import status\nfrom panther.app import GenericAPI\nfrom panther.openapi import OutputSchema\n\nclass UserSerializer(BaseModel):\n    username: str\n    age: int\n\nclass UserAPI(GenericAPI):\n    output_schema = OutputSchema(model=UserSerializer, status_code=status.HTTP_200_OK)\n    ...\n</code></pre> <p>Note: The OpenAPI integration is currently in beta. Contributions, feedback, and ideas are very welcome!</p>"},{"location":"query/","title":"Querying Documents","text":"<p>Panther ODM provides a simple, async interface for interacting with your database models. This guide covers the most common operations.</p>"},{"location":"query/#find_one","title":"find_one","text":"<p>Get a single document matching the filter.</p> <pre><code>from app.models import User\n\nuser: User = await User.find_one(id=1, name='Ali')\n# or\nuser: User = await User.find_one({'id': 1, 'name': 'Ali'})\n</code></pre> <ul> <li>Returns: An instance of the model or <code>None</code> if not found.</li> </ul>"},{"location":"query/#find","title":"find","text":"<p>Get multiple documents matching the filter.</p> <pre><code>users: Cursor = await User.find(age=18, name='Ali')\n</code></pre> <ul> <li>Returns: A <code>Cursor</code> object (see Cursor Usage).</li> </ul>"},{"location":"query/#chaining","title":"Chaining","text":"<p>You can chain <code>skip()</code>, <code>limit()</code>, and <code>sort()</code>:</p> <pre><code>users: Cursor = await User.find(age=18).skip(10).limit(10).sort([('age', -1)])\n</code></pre>"},{"location":"query/#all","title":"all","text":"<p>Get all documents in the collection.</p> <pre><code>users: Cursor = await User.all()\n</code></pre>"},{"location":"query/#first-last","title":"first / last","text":"<p>Get the first or last document matching the filter.</p> <pre><code>user: User = await User.first(age=18)\nuser: User = await User.last(age=18)\n</code></pre>"},{"location":"query/#aggregate","title":"aggregate","text":"<p>Perform an aggregation (MongoDB only).</p> <pre><code>pipeline = [\n    {'$match': {...}},\n    {'$group': {...}},\n    # ...\n]\nusers: Iterable[dict] = await User.aggregate(pipeline)\n</code></pre>"},{"location":"query/#count","title":"count","text":"<p>Count documents matching the filter.</p> <pre><code>count: int = await User.count(age=18)\n</code></pre>"},{"location":"query/#inserting-documents","title":"Inserting Documents","text":""},{"location":"query/#insert_one","title":"insert_one","text":"<p>Insert a single document.</p> <pre><code>user: User = await User.insert_one(age=18, name='Ali')\n</code></pre>"},{"location":"query/#insert_many","title":"insert_many","text":"<p>Insert multiple documents.</p> <pre><code>users = [\n    {'age': 18, 'name': 'Ali'},\n    {'age': 17, 'name': 'Saba'},\n]\nusers: list[User] = await User.insert_many(users)\n</code></pre>"},{"location":"query/#updating-documents","title":"Updating Documents","text":""},{"location":"query/#update","title":"update","text":"<p>Update the current document instance.</p> <pre><code>user = await User.find_one(name='Ali')\nawait user.update(name='Saba')\n</code></pre>"},{"location":"query/#update_one-update_many","title":"update_one / update_many","text":"<p>Update one or more documents matching a filter.</p> <pre><code>is_updated: bool = await User.update_one({'id': 1}, name='Ali')\nupdated_count: int = await User.update_many({'name': 'Saba'}, age=18)\n</code></pre>"},{"location":"query/#save","title":"save","text":"<p>Save the document (insert or update).</p> <pre><code>user = User(name='Ali')\nawait user.save()\n</code></pre>"},{"location":"query/#deleting-documents","title":"Deleting Documents","text":""},{"location":"query/#delete","title":"delete","text":"<p>Delete the current document instance.</p> <pre><code>user = await User.find_one(name='Ali')\nawait user.delete()\n</code></pre>"},{"location":"query/#delete_one-delete_many","title":"delete_one / delete_many","text":"<p>Delete one or more documents matching a filter.</p> <pre><code>is_deleted: bool = await User.delete_one(age=18)\ndeleted_count: int = await User.delete_many(age=18)\n</code></pre>"},{"location":"query/#special-methods","title":"Special Methods","text":""},{"location":"query/#find_one_or_insert","title":"find_one_or_insert","text":"<p>Get or insert a document.</p> <pre><code>is_inserted, user = await User.find_one_or_insert(age=18, name='Ali')\n</code></pre>"},{"location":"query/#find_one_or_raise","title":"find_one_or_raise","text":"<p>Get a document or raise <code>NotFoundAPIError</code>.</p> <pre><code>user: User = await User.find_one_or_raise(age=18)\n</code></pre>"},{"location":"query/#cursor-usage","title":"Cursor Usage","text":"<ul> <li>The <code>find()</code> and <code>all()</code> methods return a <code>Cursor</code> object.</li> <li>You can iterate over it or use it as a list.</li> <li>For MongoDB: <code>from panther.db.cursor import Cursor</code></li> <li>For PantherDB: <code>from pantherdb import Cursor</code></li> </ul>"},{"location":"query/#notes","title":"Notes","text":"<ul> <li>All methods are async unless otherwise noted.</li> <li>Filters can be passed as keyword arguments or as a dictionary.</li> <li>Some features (like <code>aggregate</code>) are only available for MongoDB.</li> </ul>"},{"location":"redis/","title":"Redis Integration","text":"<p>Redis is a fast, in-memory key-value store commonly used for caching, session management, real-time analytics, and pub/sub messaging. Panther supports Redis natively, allowing you to leverage its power for authentication, caching, throttling, and websocket pub/sub features.</p>"},{"location":"redis/#configuration","title":"Configuration","text":"<p>To enable Redis in Panther, fill out the <code>REDIS</code> block in your configuration file:</p> <pre><code>REDIS = {\n    'class': 'panther.db.connections.RedisConnection',\n    'host': 'localhost',  # Optional, default is 'localhost'\n    'port': 6379,         # Optional, default is 6379\n    'db': 0,              # Optional, default is 0\n    # Add any other redis-py supported parameters here\n}\n</code></pre> <p>Note: The arguments are the same as those accepted by <code>redis.Redis.__init__()</code> from the redis documentation.</p>"},{"location":"redis/#how-it-works","title":"How It Works","text":"<ul> <li>Panther creates an asynchronous Redis connection based on the <code>REDIS</code> block you define in your configuration.</li> <li> <p>You can access the Redis connection via:</p> <pre><code>from panther.db.connections import redis\n</code></pre> </li> <li> <p>Example usage:</p> <pre><code>from panther.db.connections import redis\n\nawait redis.set('name', 'Ali')\nresult = await redis.get('name')\nprint(result)\n</code></pre> </li> </ul>"},{"location":"redis/#features-using-redis","title":"Features Using Redis","text":"<ul> <li>Authentication: Store and retrieve JWT tokens for logout functionality.</li> <li>Caching: Cache responses for faster access.</li> <li>Throttling: Track and limit request rates.</li> <li>WebSocket: Manage pub/sub connections for real-time features.</li> </ul>"},{"location":"release_notes/","title":"Panther Release Notes","text":""},{"location":"release_notes/#500","title":"5.0.0","text":"<ul> <li>Add Built-In <code>OpenAPI</code></li> <li>Add Built-In <code>AdminPanel</code></li> <li>Support <code>Set-Cookie</code> in Response</li> <li>Support <code>application/x-www-form-urlencoded</code> Content Type</li> <li>Support Different <code>Middlewares</code> Per API</li> <li>Support <code>asyncio</code> in <code>panther shell</code></li> <li>Support <code>Boolean</code> type in <code>load_env()</code></li> <li>Add <code>CORSMiddleware</code></li> <li>Add <code>RedirectResponse</code></li> <li>Optimized <code>ORM</code> with smarter <code>ObjectID</code> handling</li> <li>Deprecated:<ul> <li><code>DEFAULT_CACHE_EXP</code> in configs.</li> <li>Rename <code>cache_exp_time</code> to <code>cache</code> in <code>@API</code> and <code>GenricAPI</code>.</li> <li>Rename <code>panther.throttling.Throttling</code> to <code>panther.throttling.Throttle</code>.</li> <li>Remove <code>MONITORING</code> and move its functionality as middleware in <code>panther.middelwares.monitoring.MonitoringMiddleware</code> .</li> <li><code>BaseUser.check_password(new_password=...)</code> is renamed to <code>password</code>.</li> <li><code>TemplateResponse(path=...)</code> is renamed to <code>name</code>.</li> <li>Middlewares does not support custom args for their <code>__init__</code>.</li> <li>New Style of Middleware declaration [Documentation].</li> <li>New background task declaration, <code>background_tasks.add_task(BackgroundTask(...))</code> --&gt; <code>BackgroundTask(...).submit()</code>.</li> <li><code>REDIS</code> block in configs does not support <code>websocket_db</code> anymore.</li> </ul> </li> </ul>"},{"location":"release_notes/#437","title":"4.3.7","text":"<ul> <li>Improve MultiPart-FormData Regex</li> </ul>"},{"location":"release_notes/#436","title":"4.3.6","text":"<ul> <li>Support middleware class in MIDDLEWARES</li> </ul>"},{"location":"release_notes/#434","title":"4.3.4","text":"<ul> <li>Cache Response Headers</li> </ul>"},{"location":"release_notes/#434_1","title":"4.3.4","text":"<ul> <li>Fix an issue on TemplateResponse when TEMPLATES_DIR is '.'</li> </ul>"},{"location":"release_notes/#433","title":"4.3.3","text":"<ul> <li>Fix not provided context in TemplateResponse</li> </ul>"},{"location":"release_notes/#432","title":"4.3.2","text":"<ul> <li>Support <code>Python 3.13</code> </li> </ul>"},{"location":"release_notes/#430","title":"4.3.0","text":"<ul> <li>Support <code>Jinja2 Template Engine</code> </li> </ul>"},{"location":"release_notes/#420","title":"4.2.0","text":"<ul> <li>Support <code>OPTIONS</code> method</li> </ul>"},{"location":"release_notes/#413","title":"4.1.3","text":"<ul> <li>Add <code>reload()</code> method to queries</li> <li>Add <code>get_input_model()</code> &amp; <code>get_output_model()</code> to <code>GenericAPI</code></li> <li>Support <code>per_delete()</code> &amp; <code>post_delete()</code> in <code>DeleteAPI</code> </li> <li>Support mongodb operators in <code>update(</code>) &amp; <code>update_one()</code></li> </ul>"},{"location":"release_notes/#412","title":"4.1.2","text":"<ul> <li>Fix some issues for <code>Windows</code></li> </ul>"},{"location":"release_notes/#411","title":"4.1.1","text":"<ul> <li>Fix an issue in <code>Response.prepare_data()</code> when <code>data</code> is <code>Cursor</code></li> <li>Split <code>paginate</code> and <code>template</code> in <code>Pagination</code></li> </ul>"},{"location":"release_notes/#410","title":"4.1.0","text":"<ul> <li>Support <code>prepare_response</code> in <code>Serializers</code></li> <li>Rename <code>objects()</code> to <code>cursor()</code></li> </ul>"},{"location":"release_notes/#401","title":"4.0.1","text":"<ul> <li>Fix an issue in <code>startup</code> lifespan</li> </ul>"},{"location":"release_notes/#400","title":"4.0.0","text":"<ul> <li>Move <code>database</code> and <code>redis</code> connections from <code>MIDDLEWARES</code> to their own block, <code>DATABASE</code> and <code>REDIS</code></li> <li>Make <code>Database</code> queries <code>async</code></li> <li>Make <code>Redis</code> queries <code>async</code></li> <li>Add <code>StreamingResponse</code></li> <li>Add <code>generics</code> API classes</li> <li>Add <code>login()</code> &amp; <code>logout()</code> to <code>JWTAuthentication</code> and used it in <code>BaseUser</code></li> <li>Support <code>Authentication</code> &amp; <code>Authorization</code> in <code>Websocket</code></li> <li>Rename all exceptions suffix from <code>Exception</code> to <code>Error</code> (https://peps.python.org/pep-0008/#exception-names)</li> <li>Support <code>pantherdb 2.0.0</code> (<code>Cursor</code> Added)</li> <li>Remove <code>watchfiles</code> from required dependencies</li> <li>Support <code>exclude</code> and <code>optional_fields</code> in <code>ModelSerializer</code></li> <li>Minor Improvements</li> </ul>"},{"location":"release_notes/#390","title":"3.9.0","text":"<ul> <li>Change the style of <code>ModelSerializer</code> usage </li> </ul>"},{"location":"release_notes/#382","title":"3.8.2","text":"<ul> <li>Add <code>content-type = application/json</code> header in raise response of <code>__call__</code> </li> </ul>"},{"location":"release_notes/#381","title":"3.8.1","text":"<ul> <li>Fix an issue in <code>_create_pantherdb_session()</code></li> </ul>"},{"location":"release_notes/#380","title":"3.8.0","text":"<ul> <li>Handle WebSocket connections when we have multiple workers with <code>multiprocessing.Manager</code></li> </ul>"},{"location":"release_notes/#370","title":"3.7.0","text":"<ul> <li>Add <code>ModelSerializer</code></li> </ul>"},{"location":"release_notes/#360","title":"3.6.0","text":"<ul> <li>Use <code>observable</code> pattern for loading database middleware and inheritance of the <code>Query</code> class</li> <li>Remove <code>IDType</code> from the <code>Model</code></li> <li>Change <code>encrypt_password()</code> method, now uses <code>scrypt</code> + <code>md5</code> </li> </ul>"},{"location":"release_notes/#351","title":"3.5.1","text":"<ul> <li>Set default behavior of <code>GenericWebsocket.connect</code> to ignore the connection (<code>reject</code>)</li> </ul>"},{"location":"release_notes/#350","title":"3.5.0","text":"<ul> <li>Add <code>WebsocketTestClient</code></li> </ul>"},{"location":"release_notes/#340","title":"3.4.0","text":"<ul> <li>Support <code>WebsocketMiddleware</code></li> </ul>"},{"location":"release_notes/#332","title":"3.3.2","text":"<ul> <li>Add <code>content-length</code> to response header</li> </ul>"},{"location":"release_notes/#331","title":"3.3.1","text":"<ul> <li>Check <code>ruff</code> installation on startup</li> <li>Fix an issue in <code>routing</code></li> </ul>"},{"location":"release_notes/#330","title":"3.3.0","text":"<ul> <li>Add Auto Reformat Code</li> </ul>"},{"location":"release_notes/#324","title":"3.2.4","text":"<ul> <li>Add all() query</li> <li>Add tests for <code>pantherdb</code>, <code>load_configs()</code>, <code>status.py</code>, <code>Panel</code>, <code>multipart</code>, <code>request headers</code></li> <li>Refactor <code>Headers()</code> class</li> <li>Check <code>uvloop</code> installation on <code>Panther init</code></li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#321","title":"3.2.1","text":"<ul> <li>Move <code>Startup</code> to <code>__call__</code></li> </ul>"},{"location":"release_notes/#320","title":"3.2.0","text":"<ul> <li>Support <code>Startup</code> &amp; <code>Shutdown</code> Events</li> </ul>"},{"location":"release_notes/#315","title":"3.1.5","text":"<ul> <li>Support <code>Websocket</code> in the <code>monitoring</code> </li> <li>Refactor <code>collect_all_models()</code></li> </ul>"},{"location":"release_notes/#314","title":"3.1.4","text":"<ul> <li>Check ws redis connection on the <code>init</code></li> <li>Refactor <code>Monitoring</code> class and usage</li> <li>Improve <code>logging</code> config</li> <li>Check database connection before query</li> </ul>"},{"location":"release_notes/#313","title":"3.1.3","text":"<ul> <li>Add <code>Image</code> base class </li> <li>Add <code>size</code> to <code>File</code> base class</li> <li>Improve the way of loading <code>configs</code> in <code>single-file</code> structure</li> <li>Improve <code>background_tasks.py</code>, <code>generate_ws_connection_id()</code></li> <li><code>bpython</code> removed from being the default python shell</li> <li>Improve <code>load_middlewares()</code> error handling </li> <li>Print <code>configs</code> on the <code>run</code></li> <li>Add <code>requirements.txt</code> for development </li> <li>Update <code>roadmap.jpg</code>, <code>README.md</code></li> </ul>"},{"location":"release_notes/#312","title":"3.1.2","text":"<ul> <li>Add new methods to <code>BackgroundTask</code></li> <li><code>every_seconds()</code></li> <li><code>every_minutes()</code></li> <li><code>every_hours()</code></li> <li><code>every_days()</code></li> <li><code>every_weeks()</code></li> <li><code>at()</code></li> </ul>"},{"location":"release_notes/#311","title":"3.1.1","text":"<ul> <li>Upgrade <code>PantherDB</code> version</li> <li>Add <code>first()</code>, <code>last()</code> queries</li> </ul>"},{"location":"release_notes/#310","title":"3.1.0","text":"<ul> <li>Add <code>BackgroundTasks</code></li> </ul>"},{"location":"release_notes/#303","title":"3.0.3","text":"<ul> <li>Add <code>find_one_or_raise</code> query</li> <li>Add <code>last_login</code> to <code>BaseUser</code></li> <li>Add <code>refresh_life_time</code> to <code>JWTConfig</code></li> <li>Add <code>encode_refresh_token()</code> to <code>JWTAuthentication</code></li> <li>Add <code>encrypt_password()</code></li> <li>Handle <code>PantherException</code></li> <li>Handle <code>RedisConnection</code> without <code>connection_pool</code></li> </ul>"},{"location":"release_notes/#302","title":"3.0.2","text":"<ul> <li>Added 'utf-8' encoding while opening the file \"README.md\" in setup.py</li> <li>Fixed panther shell not working issue in windows.</li> <li>Added a condition to raise error if no argument is passed to panther command in cli.</li> </ul>"},{"location":"release_notes/#301","title":"3.0.1","text":"<ul> <li>Assume content-type is 'application/json' if it was empty</li> <li>Fix an issue on creating instance of model when query is done</li> </ul>"},{"location":"release_notes/#300","title":"3.0.0","text":"<ul> <li>Support Websocket</li> <li>Implement Built-in TestClient</li> <li>Support Single-File Structure</li> <li>Support <code>bytes</code> as <code>Response.data</code></li> <li>Add <code>methods</code> to <code>API()</code></li> <li>Change <code>Request.pure_data</code> to <code>Request.data</code></li> <li>Change <code>Request.data</code> to <code>Request.validated_data</code></li> <li>Change <code>panther.middlewares.db.Middleware</code> to <code>panther.middlewares.db.DatabaseMiddleware</code></li> <li>Change <code>panther.middlewares.redis.Middleware</code> to <code>panther.middlewares.redis.RedisMiddleware</code></li> <li>Fix <code>panther run</code> command</li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#242","title":"2.4.2","text":"<ul> <li>Don't log content-type when it's not supported</li> </ul>"},{"location":"release_notes/#241","title":"2.4.1","text":"<ul> <li>Fix an issue in collect_all_models() in Windows</li> </ul>"},{"location":"release_notes/#240","title":"2.4.0","text":"<ul> <li>Handle Complex Multipart-FormData</li> </ul>"},{"location":"release_notes/#233","title":"2.3.3","text":"<ul> <li>Fix a bug in response headers</li> </ul>"},{"location":"release_notes/#232","title":"2.3.2","text":"<ul> <li>Fix a bug in Template</li> </ul>"},{"location":"release_notes/#231","title":"2.3.1","text":"<ul> <li>Handle PlainTextResponse</li> <li>Handle Custom Header in Response</li> <li>Change the way of accepting 'URLs' in configs (relative -&gt; dotted)</li> <li>Fix an issue in collect_all_models()</li> </ul>"},{"location":"release_notes/#230","title":"2.3.0","text":"<ul> <li>Handle HTMLResponse</li> </ul>"},{"location":"release_notes/#220","title":"2.2.0","text":"<ul> <li>Supporting File </li> </ul>"},{"location":"release_notes/#216","title":"2.1.6","text":"<ul> <li>Fix validation errors on nested inputs</li> </ul>"},{"location":"release_notes/#215","title":"2.1.5","text":"<ul> <li>Fix response of nested Models in _panel//"},{"location":"release_notes/#214","title":"2.1.4","text":"<ul> <li>Add access-control-allow-origin to response header</li> </ul>"},{"location":"release_notes/#213","title":"2.1.3","text":"<ul> <li>Upgrade greenlet version in requirements for python3.12</li> </ul>"},{"location":"release_notes/#212","title":"2.1.2","text":"<ul> <li>Add ruff.toml</li> <li>Add Coverage to workflows</li> <li>Fix a bug for running in Windows</li> </ul>"},{"location":"release_notes/#211","title":"2.1.1","text":"<ul> <li>Fix a bug in main.py imports</li> </ul>"},{"location":"release_notes/#210","title":"2.1.0","text":"<ul> <li>Support Sync APIs</li> </ul>"},{"location":"release_notes/#200","title":"2.0.0","text":"<ul> <li>Supporting class-base APIs</li> </ul>"},{"location":"release_notes/#1720","title":"1.7.20","text":"<ul> <li>Fix an issue in find_endpoint()</li> </ul>"},{"location":"release_notes/#1719","title":"1.7.19","text":"<ul> <li>Fix an issue in routing</li> <li>Fix an issue on return complex dict Response</li> </ul>"},{"location":"release_notes/#1718","title":"1.7.18","text":"<ul> <li>Remove uvloop from requirements for now (we had issue in windows)</li> </ul>"},{"location":"release_notes/#1716","title":"1.7.16","text":"<ul> <li>Trying to fix requirements for windows</li> <li>Minor improvement in BaseMongoDBQuery</li> </ul>"},{"location":"release_notes/#1715","title":"1.7.15","text":"<ul> <li>Fix an issue in handling form-data</li> </ul>"},{"location":"release_notes/#1714","title":"1.7.14","text":"<ul> <li>Add Cache and Throttling doc to FirstCrud</li> <li>Fix an issue in BasePantherDBQuery._merge() </li> </ul>"},{"location":"release_notes/#1713","title":"1.7.13","text":"<ul> <li>Hotfix validation of _id in Model()</li> </ul>"},{"location":"release_notes/#1712","title":"1.7.12","text":"<ul> <li>Fix a bug in routing</li> </ul>"},{"location":"release_notes/#1711","title":"1.7.11","text":"<ul> <li>Fix an issue in template</li> </ul>"},{"location":"release_notes/#1710","title":"1.7.10","text":"<ul> <li>Fix a bug in <code>collect_urls</code> and rename it to <code>flatten_urls</code></li> <li>Add General Tests</li> <li>Compatible with python3.10 (Not Tested)</li> <li>Working on docs</li> </ul>"},{"location":"release_notes/#179","title":"1.7.9","text":"<ul> <li>Working on doc</li> </ul>"},{"location":"release_notes/#178","title":"1.7.8","text":"<ul> <li>Fix a bug</li> <li>Update docs</li> </ul>"},{"location":"release_notes/#178_1","title":"1.7.8","text":"<ul> <li>Fix a bug</li> <li>Update docs</li> </ul>"},{"location":"release_notes/#177","title":"1.7.7","text":"<ul> <li>Fix a bug</li> </ul>"},{"location":"release_notes/#175","title":"1.7.5","text":"<ul> <li>Change the way of raising exception in JWTAuthentication</li> <li>Rename User model to BaseUser</li> <li>Fix template</li> </ul>"},{"location":"release_notes/#174","title":"1.7.4","text":"<ul> <li>Crop Logo</li> </ul>"},{"location":"release_notes/#173","title":"1.7.3","text":"<ul> <li>Add Throttling Doc</li> <li>Fix some issue in Doc</li> </ul>"},{"location":"release_notes/#172","title":"1.7.2","text":"<ul> <li>Add Throttling to example</li> <li>Customize install_requires in setup.py</li> <li>Improve monitoring cli command</li> </ul>"},{"location":"release_notes/#171","title":"1.7.1","text":"<ul> <li>Rename db BaseModel to Model </li> <li>Add more docs</li> </ul>"},{"location":"release_notes/#170","title":"1.7.0","text":"<ul> <li>Add Throttling</li> </ul>"},{"location":"release_notes/#161","title":"1.6.1","text":"<ul> <li>Add AdminPermission</li> </ul>"},{"location":"release_notes/#160","title":"1.6.0","text":"<ul> <li>Handle Permissions</li> </ul>"},{"location":"release_notes/#152","title":"1.5.2","text":"<ul> <li>Improve Response data serialization</li> <li>Fix a bug in JWTAuthentication</li> </ul>"},{"location":"release_notes/#151","title":"1.5.1","text":"<ul> <li>Fix error messages</li> </ul>"},{"location":"release_notes/#150","title":"1.5.0","text":"<ul> <li>Refactor Mongodb ODM</li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#140","title":"1.4.0","text":"<ul> <li>Add QUERY_LOG</li> </ul>"},{"location":"release_notes/#132","title":"1.3.2","text":"<ul> <li>Add Uvicorn to the setup requirements</li> <li>Update Readme</li> </ul>"},{"location":"release_notes/#131","title":"1.3.1","text":"<ul> <li>Fix a bug in project creation template</li> <li>Fix a bug in caching</li> </ul>"},{"location":"release_notes/#130","title":"1.3.0","text":"<ul> <li>Add PantherDB to Panther</li> <li>Remove tinydb</li> </ul>"},{"location":"release_notes/#127","title":"1.2.7","text":"<ul> <li>Fix a bug while using tinydb</li> </ul>"},{"location":"release_notes/#126","title":"1.2.6","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#125","title":"1.2.5","text":"<ul> <li>Fix install_requires issue</li> <li>Add benchmarks to docs</li> </ul>"},{"location":"release_notes/#124","title":"1.2.4","text":"<ul> <li>Remove Uvicorn From install_requires</li> <li>Working on Docs</li> </ul>"},{"location":"release_notes/#123","title":"1.2.3","text":"<ul> <li>Fix URL Routing</li> </ul>"},{"location":"release_notes/#121","title":"1.2.1","text":"<ul> <li>Path Variable Handled Successfully</li> </ul>"},{"location":"release_notes/#120","title":"1.2.0","text":"<ul> <li>Read multipart/form-data with Regex</li> </ul>"},{"location":"release_notes/#119","title":"1.1.9","text":"<ul> <li>Refactoring code style with ruff </li> <li>Add asyncio.TaskGroup() </li> </ul>"},{"location":"release_notes/#118","title":"1.1.8","text":"<ul> <li>Refactor cli run command </li> </ul>"},{"location":"release_notes/#117","title":"1.1.7","text":"<ul> <li>Add benchmark pictures to doc </li> </ul>"},{"location":"release_notes/#115","title":"1.1.5","text":"<ul> <li>Clean Readme</li> <li>Clean main.py </li> </ul>"},{"location":"release_notes/#114","title":"1.1.4","text":"<ul> <li>Update Readme </li> </ul>"},{"location":"release_notes/#113","title":"1.1.3","text":"<ul> <li>Fix a query in TinyDB </li> </ul>"},{"location":"release_notes/#112","title":"1.1.2","text":"<ul> <li>Add delete_many query to TinyDB </li> </ul>"},{"location":"release_notes/#111","title":"1.1.1","text":"<ul> <li>Add TinyDB</li> </ul>"},{"location":"release_notes/#110","title":"1.1.0","text":"<ul> <li>Debug the Template </li> </ul>"},{"location":"release_notes/#109","title":"1.0.9","text":"<ul> <li>Handle string exceptions (raise them as detail: error) </li> <li>Little debug on MongoQueries</li> </ul>"},{"location":"release_notes/#107","title":"1.0.7","text":"<ul> <li>Working on queries</li> <li>Fix a bug in query methods </li> </ul>"},{"location":"release_notes/#106","title":"1.0.6","text":"<ul> <li>Update the Template </li> </ul>"},{"location":"release_notes/#104","title":"1.0.4","text":"<ul> <li>Debug template </li> </ul>"},{"location":"release_notes/#102","title":"1.0.2","text":"<ul> <li>Add global config</li> <li>Split the BaseModels</li> <li>Worked on MongoQuery</li> <li>Set Mongo as default database while creating project </li> <li>Minor Improvement</li> </ul>"},{"location":"release_notes/#101","title":"1.0.1","text":"<ul> <li>Add alembic To Project </li> </ul>"},{"location":"release_notes/#10","title":"1.0.","text":"<ul> <li>Refactor &amp; Complete the CLI </li> </ul>"},{"location":"release_notes/#019","title":"0.1.9","text":"<ul> <li>Fix install_requires</li> </ul>"},{"location":"release_notes/#018","title":"0.1.8","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#017","title":"0.1.7","text":"<ul> <li>Update Readme</li> </ul>"},{"location":"release_notes/#016","title":"0.1.6","text":"<ul> <li>Handle Most Types as Data in Response</li> </ul>"},{"location":"release_notes/#014","title":"0.1.4","text":"<ul> <li>Working On DB Connection </li> </ul>"},{"location":"release_notes/#001","title":"0.0.1","text":"<ul> <li>Make It Ready For PyPI </li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#current-status","title":"Current Status","text":""},{"location":"roadmap/#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Report bugs and suggest features through GitHub Issues</li> <li>Submit pull requests for bug fixes and new features</li> <li>Improve documentation</li> <li>Share your experience and use cases</li> <li>Help with testing and quality assurance</li> </ol>"},{"location":"roadmap/#community-feedback","title":"Community Feedback","text":"<p>Your input is valuable! If you have any feature requests or suggestions for future development, please:</p> <ol> <li>Check existing issues to avoid duplicates</li> <li>Create a new issue with a clear description</li> <li>Include use cases and potential implementation ideas</li> <li>Label the issue appropriately</li> </ol>"},{"location":"ruff/","title":"Auto-Reformatting with Ruff","text":"<p>Panther supports automatic code reformatting using Ruff, a fast Python linter and formatter written in Rust.</p>"},{"location":"ruff/#quick-setup","title":"Quick Setup","text":"<p>To enable automatic code reformatting, set <code>AUTO_REFORMAT</code> to <code>True</code> in your configuration:</p> <pre><code>AUTO_REFORMAT = True  # Default is False\n</code></pre>"},{"location":"ruff/#how-it-works","title":"How It Works","text":"<p>When <code>AUTO_REFORMAT</code> is enabled, Panther will automatically reformat your code:</p> <ul> <li>On every application run - Code is reformatted when you start your application.</li> <li>With <code>--reload</code> flag - Code is reformatted on every file change during development</li> </ul> <p>This ensures your codebase maintains consistent formatting standards automatically.</p>"},{"location":"ruff/#installation","title":"Installation","text":"<p>The auto-reformatting feature requires the Ruff package. Install it using pip:</p> <pre><code>pip install ruff\n</code></pre>"},{"location":"ruff/#configuration","title":"Configuration","text":"<p>You can create a custom <code>ruff.toml</code> file in your project root to configure formatting rules:</p> ruff.toml<pre><code># Set the maximum line length\nline-length = 120\n\n# Set the indentation style\nindent-width = 4\n\n# Enable/disable specific rules\nselect = [\"E\", \"F\", \"I\"]\nignore = [\"E501\"]\n\n[format]\n# Formatting options\nquote-style = \"single\"\nindent-style = \"space\"\nskip-magic-trailing-comma = false\nline-ending = \"auto\"\n</code></pre>"},{"location":"ruff/#benefits","title":"Benefits","text":"<ul> <li>Consistent Code Style: Automatic formatting ensures all code follows the same style</li> <li>Time Saving: No need to manually format code or run formatters separately</li> <li>Team Collaboration: Everyone on the team gets consistent formatting automatically</li> <li>Fast Performance: Ruff is extremely fast, making the formatting process seamless</li> </ul>"},{"location":"ruff/#references","title":"References","text":"<ul> <li>Ruff Documentation</li> <li>Ruff Formatter Configuration</li> <li>Ruff Rules Reference</li> </ul>"},{"location":"serializer/","title":"Panther Serializers","text":"<p>Panther provides flexible ways to define serializers for your APIs. Serializers are responsible for validating and transforming input data. This guide covers the three supported styles and when to use each.</p>"},{"location":"serializer/#introduction","title":"Introduction","text":"<p>serializer in Panther is a class that defines how input data is validated and (optionally) transformed before being processed by your API logic. Panther supports three main styles:</p> <ul> <li> <p>Pydantic Serializer: Use a standard Pydantic model.</p> </li> <li> <p>ModelSerializer: Generate fields from a Panther model.</p> </li> <li> <p>ModelSerializer + Pydantic: Combine model-based fields with Pydantic features and custom validation.</p> </li> </ul>"},{"location":"serializer/#style-1-pydantic-serializer","title":"Style 1: Pydantic Serializer","text":"<p>Use a regular Pydantic class as your serializer. This is the most direct approach and is ideal for simple use cases or when you want full control over the fields.</p> <pre><code>from pydantic import BaseModel, Field\nfrom panther.app import API\nfrom panther.request import Request\nfrom panther.response import Response\n\nclass UserSerializer(BaseModel):\n    username: str\n    password: str\n    first_name: str = Field(default='', min_length=2)\n    last_name: str = Field(default='', min_length=4)\n\n@API(input_model=UserSerializer)\nasync def serializer_example(request: Request):\n    return Response(data=request.validated_data)\n</code></pre>"},{"location":"serializer/#style-2-modelserializer","title":"Style 2: ModelSerializer","text":"<p>Use Panther's <code>ModelSerializer</code> to automatically generate serializer fields from your model. This is useful for DRY code and consistency between your models and serializers.</p> <pre><code>from pydantic import Field\nfrom panther import status\nfrom panther.app import API\nfrom panther.db import Model\nfrom panther.request import Request\nfrom panther.response import Response\nfrom panther.serializer import ModelSerializer\n\nclass User(Model):\n    username: str\n    password: str\n    first_name: str = Field(default='', min_length=2)\n    last_name: str = Field(default='', min_length=4)\n\n# Option 1: Specify fields explicitly\nclass UserModelSerializer(ModelSerializer):\n    class Config:\n        model = User\n        fields = ['username', 'first_name', 'last_name']\n        required_fields = ['first_name']\n\n# Option 2: Exclude specific fields\nclass UserModelSerializer(ModelSerializer):\n    class Config:\n        model = User\n        fields = '*'\n        required_fields = ['first_name']\n        exclude = ['id', 'password']\n\n@API(input_model=UserModelSerializer)\nasync def model_serializer_example(request: Request):\n    return Response(data=request.validated_data)\n</code></pre>"},{"location":"serializer/#style-3-modelserializer-with-pydantic-features","title":"Style 3: ModelSerializer with Pydantic Features","text":"<p>Combine <code>ModelSerializer</code> with Pydantic features for advanced use cases. This allows you to add custom fields, validators, and configuration.</p> <pre><code>from pydantic import Field, field_validator, ConfigDict\nfrom panther import status\nfrom panther.app import API\nfrom panther.db import Model\nfrom panther.request import Request\nfrom panther.response import Response\nfrom panther.serializer import ModelSerializer\n\nclass User(Model):\n    username: str\n    password: str\n    first_name: str = Field(default='', min_length=2)\n    last_name: str = Field(default='', min_length=4)\n\nclass UserModelSerializer(ModelSerializer):\n    model_config = ConfigDict(str_to_upper=True)\n    age: int = Field(default=20)\n    is_male: bool\n    username: str\n\n    class Config:\n        model = User\n        fields = ['first_name', 'last_name']\n        required_fields = ['first_name']\n        optional_fields = ['last_name']\n\n    @field_validator('username')\n    def validate_username(cls, username):\n        print(f'{username=}')\n        return username\n\n@API(input_model=UserModelSerializer)\nasync def model_serializer_example(request: Request):\n    return Response(data=request.validated_data)\n</code></pre>"},{"location":"serializer/#comparison-table","title":"Comparison Table","text":"Feature Pydantic Serializer ModelSerializer ModelSerializer + Pydantic Model-based fields \u274c \u2705 \u2705 Custom fields \u2705 \u274c \u2705 Pydantic validators \u2705 \u274c \u2705 Field inclusion/exclude Manual Configurable Configurable Best for Simple cases DRY, model-aligned Advanced/Hybrid"},{"location":"serializer/#notes-best-practices","title":"Notes &amp; Best Practices","text":"<ul> <li><code>ModelSerializer</code> uses your model's field types and default values for validation.</li> <li><code>Config.model</code> and <code>Config.fields</code> are required for <code>ModelSerializer</code>.</li> <li>Use <code>Config.required_fields</code> to force fields to be required.</li> <li>Use <code>Config.optional_fields</code> to force fields to be optional.</li> <li>A field cannot be in both <code>required_fields</code> and <code>optional_fields</code>.</li> <li>If you use <code>required_fields</code> or <code>optional_fields</code>, those fields must also be listed in <code>fields</code>.</li> <li>You can use <code>'*'</code> for <code>fields</code>, <code>required_fields</code>, or <code>optional_fields</code> to include all model fields.</li> <li><code>Config.exclude</code> is useful when <code>fields</code> is set to <code>'*'</code>.</li> <li>You can add custom fields and validators when combining <code>ModelSerializer</code> with Pydantic features.</li> </ul>"},{"location":"single_file/","title":"Using Panther in a Single-File Structure","text":"<p>If you prefer to work with <code>Panther</code> in a single Python file, follow the steps below to quickly set up and run your API.</p>"},{"location":"single_file/#step-1-define-your-apis","title":"Step 1: Define Your APIs","text":"<p>Write your API endpoints as usual using the <code>@API()</code> decorator or inheriting from <code>GenericAPI</code>:</p> main.py<pre><code>from panther.app import API\n\n@API()\nasync def hello_world_api():\n    return {'detail': 'Hello World'}\n</code></pre>"},{"location":"single_file/#step-2-create-a-url-routing-dictionary","title":"Step 2: Create a URL Routing Dictionary","text":"<p>Map your endpoints to their respective URLs in a dictionary (commonly named <code>url_routing</code>):</p> main.py<pre><code>url_routing = {\n    '/': hello_world_api,\n}\n</code></pre>"},{"location":"single_file/#step-3-initialize-the-panther-app","title":"Step 3: Initialize the Panther App","text":"<p>Create an instance of the <code>Panther</code> app, passing your current module name and the URL routing dictionary:</p> main.py<pre><code>from panther import Panther\nfrom panther.app import API\n\n@API()\nasync def hello_world_api():\n    return {'detail': 'Hello World'}\n\nurl_routing = {\n    '/': hello_world_api,\n}\n\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre>"},{"location":"single_file/#step-4-run-your-project","title":"Step 4: Run Your Project","text":"<p>Use the following command to start your application:</p> <pre><code>panther run main:app\n</code></pre>"},{"location":"single_file/#additional-notes","title":"Additional Notes","text":"<ul> <li>The <code>urls</code> parameter is required unless you provide the URLs via configuration.</li> <li>When you pass <code>configs=__name__</code> to the <code>Panther</code> constructor, Panther will load the configuration from the current file. If you omit this, Panther defaults to loading configuration from <code>core/configs.py</code>.</li> </ul>"},{"location":"templates/","title":"Template Responses","text":"<p>Panther provides <code>TemplateResponse</code> for serving HTML templates with dynamic content. This guide explains how to configure and use templates in your Panther application.</p>"},{"location":"templates/#configuration","title":"Configuration","text":"<p>To use <code>TemplateResponse</code> with template files, you must configure the <code>TEMPLATES_DIR</code> setting in your application configuration.</p>"},{"location":"templates/#setting-templates-directory","title":"Setting Templates Directory","text":"<p>The <code>TEMPLATES_DIR</code> can be a single string or a list of strings representing template directory paths:</p> <pre><code># Single directory\nTEMPLATES_DIR = 'templates/'\n\n# Multiple directories (searched in order)\nTEMPLATES_DIR = ['templates/', 'app/templates/', 'shared/templates/']\n</code></pre> <p>Default value: <code>'./'</code> (current directory)</p>"},{"location":"templates/#usage","title":"Usage","text":""},{"location":"templates/#using-template-files-recommended","title":"Using Template Files (Recommended)","text":"<p>When you have template files, use the <code>name</code> parameter to specify the template file:</p> <pre><code>from panther.app import API\nfrom panther.response import TemplateResponse\n\n\n@API()\ndef my_html():\n    return TemplateResponse(\n        name='index.html', \n        context={'name': 'Ali', 'title': 'Welcome'}\n    )\n</code></pre> <p>Benefits:</p> <ul> <li>Cleaner code separation</li> <li>Template reusability</li> <li>Better maintainability</li> </ul>"},{"location":"templates/#using-inline-html-content","title":"Using Inline HTML Content","text":"<p>For simple cases or when you need to generate HTML dynamically, you can pass the HTML content directly:</p> <pre><code>from panther.app import API\nfrom panther.response import TemplateResponse\n\n\n@API()\ndef my_html():\n    html_content = open('index.html', 'r').read()\n    return TemplateResponse(\n        source=html_content, \n        context={'name': 'Ali', 'title': 'Welcome'}\n    )\n</code></pre> <p>Note: This approach requires you to manage the HTML content manually and doesn't provide the benefits of template files.</p>"},{"location":"templates/#template-context","title":"Template Context","text":"<p>The <code>context</code> parameter allows you to pass variables to your templates:</p> <pre><code>from panther.app import API\nfrom panther.response import TemplateResponse\n\ndef get_user(user_id: int):\n    return ...\n\n@API()\ndef user_profile(user_id: int):\n    user = get_user(user_id)  # Your user fetching logic\n    return TemplateResponse(\n        name='profile.html',\n        context={\n            'user': user,\n            'page_title': f'{user.name}\\'s Profile',\n            'is_admin': user.role == 'admin'\n        }\n    )\n</code></pre>"},{"location":"templates/#example-project-structure","title":"Example Project Structure","text":"<pre><code>my_panther_app/\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 configs.py\n\u2502   \u2514\u2500\u2500 urls.py\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 views.py\n\u251c\u2500\u2500 templates/\n\u2502   \u251c\u2500\u2500 base.html\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 profile.html\n\u2514\u2500\u2500 main.py\n</code></pre> <p>With this structure, your configuration would be:</p> core/configs.py<pre><code>TEMPLATES_DIR = 'templates/'\n</code></pre>"},{"location":"timezone/","title":"Timezone Configuration","text":"<p>Panther provides built-in timezone support to ensure consistent datetime handling across your application.</p>"},{"location":"timezone/#configuration","title":"Configuration","text":"<p>You can specify your timezone in the configuration using the <code>TIMEZONE</code> setting:</p> <pre><code>TIMEZONE = 'UTC'  # Options are available in `pytz.all_timezones`\n</code></pre> <p>To see all available timezone options, you can run:</p> <pre><code>import pytz\nprint(pytz.all_timezones)\n</code></pre> <p>This will show you the complete list of timezone identifiers you can use in your <code>TIMEZONE</code> configuration.</p>"},{"location":"timezone/#using-panthers-timezone-aware-datetime","title":"Using Panther's Timezone-Aware DateTime","text":"<p>Panther provides a utility function <code>panther.utils.timezone_now()</code> that returns the current datetime relative to your configured timezone:</p> <pre><code>from panther.utils import timezone_now\n\n# Get current datetime in your configured timezone\ncurrent_time = timezone_now()\nprint(current_time)  # 2024-01-15 14:30:00+00:00 (if TIMEZONE='UTC')\n</code></pre>"},{"location":"timezone/#where-its-used","title":"Where It's Used","text":"<p>The <code>timezone_now()</code> function is automatically used in several Panther components:</p> <ul> <li>User Authentication: <code>BaseUser.date_created</code> and <code>BaseUser.last_login</code> use timezone-aware timestamps</li> <li>Background Tasks: DateTime checking for scheduled and queued tasks</li> </ul> <p>Use <code>timezone_now()</code> Instead of <code>datetime.now()</code>, to maintain consistency across your application.</p>"},{"location":"urls/","title":"URL Configuration in Panther","text":"<p>Panther requires you to define your application's URL routing. You can provide this configuration in two ways:</p> <ol> <li>Global Config: Specify a dotted path to a dictionary of URLs in your configuration file.</li> <li>Direct Argument: Pass the URL dictionary directly to the <code>Panther(...)</code> constructor (commonly used in single-file applications).</li> </ol>"},{"location":"urls/#how-to-configure-urls","title":"How to Configure URLs","text":"<ul> <li>The <code>URLs</code> config should be a dotted path (string) pointing to your root URL dictionary.<ul> <li>Example: <code>URLs = 'path.to.module.url_dict'</code></li> </ul> </li> <li>The target of <code>URLs</code> must be a Python <code>dict</code>.</li> <li>In the URL dictionary, each key is a URL path, and each value is either an endpoint (function/class) or another nested dictionary for sub-routing.</li> </ul>"},{"location":"urls/#path-variables","title":"Path Variables","text":"<p>You can define variables in your URL paths using angle brackets (<code>&lt;variable_name&gt;</code>):</p> <ul> <li>Example path: <code>user/&lt;user_id&gt;/blog/&lt;title&gt;/</code></li> <li>The corresponding endpoint must accept parameters with the same names.</li> <li>Panther will automatically cast arguments to the expected types and raise an error if the types do not match.</li> </ul> Function-basedClass-based app/apis.py<pre><code>@API()\nasync def profile_api(user_id: int, title: str, is_alive: bool):\n    ...\n</code></pre> app/apis.py<pre><code>class MyAPI(GenericAPI):\n    async def get(self, user_id: int, title: str, is_alive: bool):\n        ...\n</code></pre>"},{"location":"urls/#example-global-config-structure","title":"Example: Global Config Structure","text":"<p>Specify a dotted path to a dictionary of URLs in your configuration file.</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502     \u251c\u2500\u2500 apis.py\n\u2502     \u2514\u2500\u2500 urls.py\n\u2514\u2500\u2500 core\n      \u251c\u2500\u2500 configs.py\n      \u2514\u2500\u2500 urls.py\n</code></pre> core/configs.py<pre><code>URLs = 'core.urls.url_routing'\n</code></pre> core/urls.py<pre><code>from app.urls import app_urls\n\nurl_routing = {\n    'user/': app_urls,\n}\n</code></pre> app/urls.py<pre><code>from app.apis import *\n\napp_urls = {\n    'login/': login_api,\n    'logout/': logout_api,\n    '&lt;user_id&gt;/blog/&lt;title&gt;/&lt;is_alive&gt;/': profile_api,\n}\n</code></pre> app/apis.py<pre><code>from panther import API\n\n@API()\nasync def profile_api(user_id: int, title: str, is_alive: bool):\n    ...\n</code></pre>"},{"location":"urls/#example-single-file-structure","title":"Example: Single-File Structure","text":"<p>You can pass the URL dictionary directly to Panther:</p> main.py<pre><code># Other codes ...\n\nurls = {\n    '/': first_api,\n}\n\napp = Panther(__name__, configs=__name__, urls=urls)\n</code></pre>"},{"location":"user_model/","title":"User Model Configuration","text":"<p>You can specify which model should be used as your User model by setting the <code>USER_MODEL</code> variable in your configuration files.</p> <p>The value of <code>USER_MODEL</code> should be the import path (address) of a model class that inherits from <code>panther.db.models.BaseUser</code>. Panther relies on this model for user authentication and management within the AdminPanel and all built-in authentication classes.</p>"},{"location":"user_model/#usage","title":"Usage","text":"<ul> <li>Login and Authentication in AdminPanel: The specified User model will be used to authenticate users accessing the AdminPanel.</li> <li>Built-in Authentication Classes: All built-in authentication mechanisms will utilize this User model for user-related operations.</li> </ul>"},{"location":"user_model/#default-value","title":"Default Value","text":"<p>If you do not specify a <code>USER_MODEL</code>, Panther will use <code>panther.db.models.BaseUser</code> as the default User model.</p>"},{"location":"user_model/#example","title":"Example","text":"<pre><code># In your configuration file\nUSER_MODEL = 'your_app.models.CustomUser'\n</code></pre>"},{"location":"websocket/","title":"WebSocket Support in Panther","text":"<p>WebSockets enable you to build interactive, real-time features such as chat, notifications, and live updates.</p>"},{"location":"websocket/#structure-requirements","title":"Structure &amp; Requirements","text":""},{"location":"websocket/#creating-a-websocket-class","title":"Creating a WebSocket Class","text":"<p>Create a WebSocket handler class in <code>app/websockets.py</code> by inheriting from <code>GenericWebsocket</code>:</p> app/websockets.py<pre><code>from panther.websocket import GenericWebsocket\n\nclass BookWebsocket(GenericWebsocket):\n    async def connect(self):\n        await self.accept()\n        print(f'{self.connection_id=}')\n\n    async def receive(self, data: str | bytes):\n        # Echo the received message back to the client\n        await self.send(data=data)\n</code></pre>"},{"location":"websocket/#registering-websocket-urls","title":"Registering WebSocket URLs","text":"<p>Register your WebSocket class in <code>app/urls.py</code>:</p> app/urls.py<pre><code>from app.websockets import BookWebsocket\n\nurls = {\n    'ws/book/': BookWebsocket,\n}\n</code></pre> <p>Panther supports WebSocket routing just like APIs.</p>"},{"location":"websocket/#how-it-works","title":"How It Works","text":"<ol> <li>Client Connection: The client connects to your <code>ws/book/</code> URL using the WebSocket protocol.</li> <li>Connection Handling: The <code>connect()</code> method of your WebSocket class is called.</li> <li>Validation: You can validate the connection using <code>self.headers</code>, <code>self.query_params</code>, etc.</li> <li>Accept/Reject: Accept the connection with <code>self.accept()</code>. If not accepted, it is rejected by default.</li> <li>Connection ID: Each connection gets a unique <code>connection_id</code> (accessible via <code>self.connection_id</code>). You may want to store this in a database or cache.</li> <li>Receiving Messages: Incoming messages are handled by the <code>receive()</code> method. Messages can be <code>str</code> or <code>bytes</code>.</li> <li>Sending Messages:<ul> <li>Within the WebSocket class: Use <code>self.send(data)</code>.</li> <li>Outside the WebSocket class: Use <code>send_message_to_websocket()</code>:   <pre><code>from panther.websocket import send_message_to_websocket\nawait send_message_to_websocket(connection_id='7e82d57c9ec0478787b01916910a9f45', data='New Message From WS')\n</code></pre></li> </ul> </li> </ol>"},{"location":"websocket/#advanced-usage","title":"Advanced Usage","text":""},{"location":"websocket/#authentication","title":"Authentication","text":"<p>You can enable authentication in your WebSocket class by setting <code>auth = True</code> and specifying your authentication class in the configuration with <code>WS_AUTHENTICATION</code>.  Panther will use the <code>authentication()</code> method of this class to authenticate the user.  There are several built-in options, but we recommend <code>QueryParamJWTAuthentication</code> for WebSocket authentication.</p> <pre><code>WS_AUTHENTICATION = 'panther.authentications.QueryParamJWTAuthentication'\n</code></pre> <p>This will set <code>self.user</code> to a <code>UserModel</code> instance or <code>None</code>. The connection will be rejected if any exception occurs during authentication.</p> app/websockets.py<pre><code>from panther.websocket import GenericWebsocket\n\nclass MyWebSocket(GenericWebsocket):\n    auth = True\n\n    async def connect(self):\n        print(self.user)\n        ...\n</code></pre>"},{"location":"websocket/#permissions","title":"Permissions","text":"<p>You can implement your authorization logic using permission classes. Any class that inherits from <code>panther.permissions.BasePermission</code> or implements an <code>authorization()</code> method can be used as a permission class.</p> <p>Pass a list of permission classes to your WebSocket class, and Panther will call each class's <code>authorization()</code> method. If any return <code>False</code>, the connection will be rejected.</p> <p>The <code>authorization()</code> method should be an <code>async classmethod</code>.</p> app/websockets.py<pre><code>from panther.websocket import Websocket, GenericWebsocket\nfrom panther.permissions import BasePermission\n\nclass MyPermission(BasePermission):\n    @classmethod\n    async def authorization(cls, request: Websocket) -&gt; bool:\n        return True\n\nclass MyWebSocket(GenericWebsocket):\n    permissions = [MyPermission]\n\n    async def connect(self):\n        ...\n</code></pre>"},{"location":"websocket/#multiple-workers-redis","title":"Multiple Workers &amp; Redis","text":"<ul> <li>Recommended: For running WebSockets with multiple workers, add Redis to your configuration. See Adding Redis</li> <li>Without Redis: If you do not use Redis but want to run WebSockets with multiple workers (e.g., with Gunicorn), use the <code>--preload</code> flag:   <pre><code>gunicorn -w 10 -k uvicorn.workers.UvicornWorker main:app --preload\n</code></pre></li> </ul>"},{"location":"websocket/#closing-connections","title":"Closing Connections","text":"<ul> <li>Within the WebSocket class: <pre><code>from panther import status\nawait self.close(code=status.WS_1000_NORMAL_CLOSURE, reason='Closing connection')\n</code></pre></li> <li>Outside the WebSocket class: <pre><code>from panther import status\nfrom panther.websocket import close_websocket_connection\nawait close_websocket_connection(connection_id='7e82d57c9ec0478787b01916910a9f45', code=status.WS_1008_POLICY_VIOLATION, reason='Closing connection')\n</code></pre></li> </ul>"},{"location":"websocket/#path-variables","title":"Path Variables","text":"<p>You can define path variables in your WebSocket URL. These will be passed to the <code>connect()</code> method:</p> <pre><code>from panther.websocket import GenericWebsocket\n\nclass UserWebsocket(GenericWebsocket):\n    async def connect(self, user_id: int, room_id: str):\n        await self.accept()\n\nurls = {\n    '/ws/&lt;user_id&gt;/&lt;room_id&gt;/': UserWebsocket\n}\n</code></pre>"},{"location":"websocket/#example","title":"Example","text":""},{"location":"websocket/#example-client-code","title":"Example Client Code","text":"<p>Here's a simple example using JavaScript:</p> websocket.js<pre><code>const ws = new WebSocket('ws://127.0.0.1:8000/ws/book/');\nws.onopen = () =&gt; {\n    ws.send('Hello, server!');\n};\nws.onmessage = (event) =&gt; {\n    console.log('Received:', event.data);\n};\nws.onclose = () =&gt; {\n    console.log('Connection closed');\n};\n</code></pre>"},{"location":"websocket/#echo-example","title":"Echo Example","text":"<p>Full echo example with WebSocket:</p> <p>main.py<pre><code>from panther import Panther\nfrom panther.app import GenericAPI\nfrom panther.response import HTMLResponse\nfrom panther.websocket import GenericWebsocket\n\nclass EchoWebsocket(GenericWebsocket):\n    async def connect(self, **kwargs):\n        await self.accept()\n\n    async def receive(self, data: str | bytes):\n        await self.send(data)\n\nclass MainPage(GenericAPI):\n    def get(self):\n        template = \"\"\"\n        &lt;input id=\"msg\"&gt;&lt;button onclick=\"s.send(msg.value)\"&gt;Send&lt;/button&gt;\n        &lt;ul id=\"log\"&gt;&lt;/ul&gt;\n        &lt;script&gt;\n            const s = new WebSocket('ws://127.0.0.1:8000/ws');\n            s.onmessage = e =&gt; log.innerHTML += `&lt;li&gt;&lt;- ${msg.value}&lt;/li&gt;&lt;li&gt;-&gt; ${e.data}&lt;/li&gt;`;\n        &lt;/script&gt;\n        \"\"\"\n        return HTMLResponse(template)\n\nurl_routing = {\n    '': MainPage,\n    'ws': EchoWebsocket,\n}\napp = Panther(__name__, configs=__name__, urls=url_routing)\n</code></pre> Run with <code>panther run main:app</code> and visit <code>http://127.0.0.1:8000</code>.</p>"},{"location":"websocket/#tips-notes","title":"Tips &amp; Notes","text":"<ul> <li>Connection Validation: Always validate connections in <code>connect()</code> using headers or query parameters as needed.</li> <li>Connection IDs: Store <code>connection_id</code> if you need to send messages to clients outside the WebSocket class.</li> <li>Multiple Workers: Use Redis for scaling WebSockets across multiple workers.</li> <li>Error Handling: Implement error handling in your WebSocket methods for production use.</li> <li>Security: Always validate and sanitize incoming data.</li> </ul> <p>Enjoy building with Panther WebSockets!</p>"}]}